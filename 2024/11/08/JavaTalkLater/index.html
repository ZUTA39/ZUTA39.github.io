<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Java后日谈 | ZUTA的观测站</title><meta name="keywords" content="编程语言"><meta name="author" content="ZUTA39,1307603452@qq.com"><meta name="copyright" content="ZUTA39"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Java后日谈"><meta name="application-name" content="Java后日谈"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Java后日谈"><meta property="og:url" content="https://zuta39.github.io/2024/11/08/JavaTalkLater/index.html"><meta property="og:site_name" content="ZUTA的观测站"><meta property="og:description" content="这一部分主要是深入的知识，笔记来源于韩顺平老师的Java课程。 前情提要关于main方法的更多细节 运行Java虚拟机负责运行主方法。 参数 String[] args 这一参数由程序运行时传入，传入的内容也由传入时决定。 静态的（static）main方法静态的特点与一般方法的静态相同。即：只能直"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://zuta39.github.io/img/article_background2.jpg"><meta property="article:author" content="ZUTA39"><meta property="article:tag" content="ZUTA, Blog"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://zuta39.github.io/img/article_background2.jpg"><meta name="description" content="这一部分主要是深入的知识，笔记来源于韩顺平老师的Java课程。 前情提要关于main方法的更多细节 运行Java虚拟机负责运行主方法。 参数 String[] args 这一参数由程序运行时传入，传入的内容也由传入时决定。 静态的（static）main方法静态的特点与一般方法的静态相同。即：只能直"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://zuta39.github.io/2024/11/08/JavaTalkLater/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?<script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?f0dab5540558a6749d905f221882b157"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})(); </script>";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"Σ(°ロ°)你真的要走吗","backTitle":"(´ω｀)喜欢您来~"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"遇到困难睡大觉！😴","startTime":0,"endTime":6},{"greeting":"早上好！, 希望你没有早八😼","startTime":6,"endTime":9},{"greeting":"上午好, 一起学习吧😸","startTime":10,"endTime":12},{"greeting":"午安👋, 我去午睡啦~","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 开炫！🍔","startTime":19,"endTime":19},{"greeting":"晚上好, 好好放松一下吧😽","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"api","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🍟 薯条教信徒"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: ZUTA39","link":"链接: ","source":"来源: ZUTA的观测站","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: {"enable":true,"delay":100,"shiftDelay":200},
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ZUTA的观测站',
  title: 'Java后日谈',
  postAI: '',
  pageFillDescription: '前情提要, 关于main方法的更多细节, 代码块（*）, 静态方法与属性的使用–单例设计模式, final关键字, 基本使用, 注意事项与细节讨论, 关于继承中的super, 抽象与接口, 抽象（abstract）, 抽象基本介绍, 抽象类的注意事项与细节, 接口（interface）, 接口基本介绍, 接口注意事项, 继承与接口的比较, 接口的多态, 内部类, 内部类的基本介绍, 内部类的分类, 局部内部类, 匿名内部类, 匿名内部类的基本语法, 使用场景, 成员内部类, 静态内部类, 枚举与注解, 枚举, 自定义枚举类, Enum枚举类, 枚举类的基本语法, 方法, 使用细节, 注解, Override注解, Despressted注解, SuppressWarnings注解, 四种元注解（*）, 异常, 异常体系图, 常见的异常, 运行时异常, 编译异常, 异常处理, 异常处理概念, 异常处理分类, 自定义异常, throw和throws的对比, 常用类, 包装类（Wrapper）, 包装类的基本概念, 包装类的转换, 包装类的常用静态方法与属性, 包装类注意事项, String类, String类的基本概念, String类的常用构造器与对象创建, 字符串特性, String类的常用方法, StringBuffer类和StringBuilder类, StringButter类, StringBuffer类简介, StringBuffer类与String类的比较, StringBuffer实例化, StringBuffer类的常用方法, StringBuilder类, StringBuilder类简介, StringBuilder常用方法, String、StringBuilder、StringBuffer的比较, Math类, Arrays类, System类, System类的常见方法, BigInteger类和BigDecimal类, 日期类, 第一代日期类–Date类, Date的特定格式化解析输出（Date -gt String）, String -gt Date, 第二代日期类–Calendar类, 第三代日期类, 前两代日期类的不足分析, JDK8引入的第三代日期类, 常用方法, 格式日期类–DateTimeFormatter（Localxx -gt String）, 时间戳–Instant, 集合, 集合框架体系, Collection接口, 遍历方式, 迭代器, 增强for循环, List 接口, ArrayList, LinkedList, Vector, Set 接口, HashSet, LinkedHashSet, TreeSet, Map, 遍历方法, HashMap（常用）, HashTable, Properties, TreeMap, Collections工具类这一部分主要是深入的知识笔记来源于韩顺平老师的课程前情提要关于方法的更多细节运行虚拟机负责运行主方法参数这一参数由程序运行时传入传入的内容也由传入时决定静态的方法静态的特点与一般方法的静态相同即只能直接调用同为静态的属性或方法限定在同一个类中如果想调用非静态的只能先创建实例再调用未完成代码块即是可重复调用的构造器代码构造器的补充由花括号包围无论构造器有多少重载都会先调用代码块里的内容再调用构造器代码块使用注意事项如果代码块前有修饰作用就是对类进行初始化随着类的加载而执行类什么时候加载创建对象实例时创建子类对象实例时父类也会被加载使用类的静态成员时普通代码块在创建对象实例时会被隐式调用每被创建一次就调用一次在使用类的静态成员时普通代码块不会被执行调用时的顺序在创建一个对象时在类中的调用顺序是先调用静态代码块与静态属性都有就按定义顺序来再调用普通代码块与普通属性同上最后调用方法在继承时呢构造器的前面其实隐含了和调用普通代码块静态代码块属性初始化在类加载时就已经执行完毕了因此继承先于构造器与普通代码块执行静态代码块只能直接调用静态成员普通代码块可以调用任意成员创建一个子类对象时整体的调用顺序如下父类静态代码块与静态属性子类静态代码块与静态属性父类普通代码块与普通属性构造方法子类普通代码块与普通属性构造方法静态方法与属性的使用单例设计模式所谓单例模式就是采用一定的方法保证在整个的软件系统中对某个类只能存在一个对象实例并且该类只提供一个取得其对象实例的方法适用于单一特点的类如何保证只有一个实例呢饿汉式由于对象是的所以无论有没有使用它都会在类加载时创建将构造器私有化在类的内部直接创建对象提供一个公共的因为要调用对象所以得是属性方法返回这个对象懒汉式不用就不创建将构造器私有化定义一个对象作为成员属性不是一个提供一个公共的方法并附上判断如果中的对象确实为空就将这个对象出来这样就可以保证只有在这个方法被调用时对象才会被创建后面再调用也还是这同一个对象关键字基本使用关键字可以修饰类属性方法和局部变量局部变量是指在方法构造方法或代码块中定义的变量它们的作用域仅限于定义它们的方法构造方法或代码块内当方法构造方法或代码块执行完毕后局部变量就会被销毁局部变量不能有访问修饰符如等因为它们的作用范围仅限于方法内部在以下情况会使用不希望类被继承不希望父类某个方法被子类覆盖重写不希望某个属性值被修改常量不希望某个局部变量被修改注意事项与细节讨论修饰的属性称为常量命名格式为大写字母下划线常量必须初始化常量可在以下位置初始化定义时在构造器中在代码块中如果修饰的属性是静态的那么初始化的位置只能是定义时在静态代码块中不能在构造器中赋值类只是不能继承其他的事还是可以干的关于继承中的关键字在中有以下几种主要用法调用父类的构造方法在子类的构造方法中可以使用调用父类的构造方法必须是构造方法中的第一条语句如果父类有参数化的构造方法可以使用参数列表调用相应的构造方法访问父类的成员变量当子类和父类有同名的成员变量时可以使用变量名来访问父类的成员变量调用父类的方法当子类重写了父类的方法时可以使用方法名来调用父类的版本下面是一个示例代码展示了的这些用法调用父类的无参构造方法调用父类的有参构造方法调用父类的方法访问父类的成员变量抽象与接口抽象抽象基本介绍当父类的某些方法需要声明但是又不确定如何实现时即父类方法不确定可以将其声明为抽象方法没有实现没有方法体的方法这个类也就是抽象类一般来说抽象类会被继承由其子类来实现抽象方法抽象类的注意事项与细节抽象类不能被直接实例化不绝对注意分为以下两种情况系统提供的抽象类通常会提供静态工厂方法如来返回该抽象类的具体实现类的实例例如返回一个的具体实现类实例自定义的抽象类你需要定义一个具体的子类来继承该抽象类然后实例化这个子类抽象类可以没有方法可以有任意成员一旦包含方法这个类必须声明为只能修饰类和方法不能修饰属性和其他的抽象方法不能使用和修饰因为它们与重写矛盾即抽象类只能是抽象可以说是继承的拓展版接口接口基本介绍接口就是给出一些没有实现的方法封装到一起等某个类要使用时再根据具体情况具体实现这些方法语法接口类属性方法使用接口的类属性属性必须实现的接口的抽象方法接口主要用于规范化一些类接口注意事项接口默认为抽象类不需要特意加因此抽象类适用的它也适用接口中的所有方法默认为抽象类实现接口可以不用实现接口的方法一个类同时可以实现多个接口接口中的属性实际上是的而且是由于接口中的属性实际上是的所以可以直接用接口名访问接口不可以继承其他类但是可以继承多个别的接口不能使用关键字来实现另一个接口相反接口可以通过关键字来继承其他接口省略接口只能是或默认的继承与接口的比较当子类继承了父类就自动拥有父类的功能如果子类需要拓展功能就可以通过实现接口来拓展简单来讲就是实现接口是对单继承机制的一种补充继承的价值主要在于解决代码的复用性和可维护性接口的价值主要在于设计好各种规范方法让其它类去实现更加灵活继承满足的关系而接口满足的关系接口在一定程度上实现了代码解耦即接口规范性动态绑定接口的多态如果接口继承了接口而类实现了接口那么实际上就相当于类也实现了接口这就是所谓的接口多态传递当接口作为方法参数时可以将实现了这个接口的类的实例传递给它这是因为接口类型的参数可以接受任何实现该接口的类的实例类似继承的多态内部类内部类的基本介绍一个类的内部又完整地嵌套了另一个类结构被嵌套的那个类称为内部类嵌套其他类的类称为外部类内部类的最大特点就是可以直接访问私有属性并且可以体现类与类之间的包含关系内部类是类的五大成员之一类的五大成员有属性方法构造器代码块内部类基本语法外部类内部类外部其他类内部类的分类定义在外部类局部位置上比如方法内或代码块内局部内部类有类名匿名内部类无类名定义在外部类成员位置上成员内部类无修饰静态内部类使用修饰局部内部类局部内部类本质仍然是一个类与普通类区别在于它可以直接访问外部类的所有成员包括私有的局部内部类不能添加访问修饰符因为它与局部变量地位相同但是可以加关键字局部变量是什么局部内部类作用域仅仅在定义它的方法或代码块中与局部变量相同局部内部类访问外部类的成员可以直接访问外部类访问局部内部类的成员需要先创建对象再访问在作用域内如果外部类和局部内部类成员重名默认遵守就近原则假如只想访问外部类的那个成员使用外部类名成员变量名假如成员变量不是静态的那么就是必须的访问外部类名本质就是外部类的对象即哪个对象调用了包含这个局部内部类的方法外部类名就是哪个对象示例访问外部类的成员访问局部变量需要在外部类定义这个局部内部类的方法中实例化局部内部类因为实例化以后才能使用局部内部类的方法相应的应用场景不太多匿名内部类匿名内部类的基本语法本质是类内部类该类没有名字其实也不是没有只不过是系统取的名字而且被隐藏了该类同时还是一个对象可以直接访问外部类的所有成员包括私有的不能添加访问修饰符因为它的地位就是一个局部变量作用域仅仅在定义它的方法或代码中外部其他类不能访问匿名内部类如果外部类和匿名内部类成员重名默认遵守就近原则假如只想访问外部类的那个成员使用外部类名成员变量名假如成员变量不是静态的那么就是必须的访问基本语法类或接口参数列表类体基于抽象类与接口的匿名内部类需求想使用某接口但是这个类只是使用一次相当于是使用接口实现接口中的方法的编译类型是的运行类型是系统起的名字即内部类的名称基于类的内部类需求想使用某类但是这个类只是使用一次相当于是使用继承可以进行继承的所有操作的编译类型是的运行类型是系统起的名字即内部类的名称会继承了抽象也是一样的道理注由于匿名内部类兼有类和对象的特点以下两种调用方法的方式都可以运行省略第一种重写父类方法省略第二种重写父类方法省略使用场景当作实参直接传递简洁高效例如创建接口类型的匿名内部类传递给其他方法不用专门写一个类以参数方式使用匿名内部类实现接口运行这个程序时输出将是这表明匿名内部类的方法被调用了通过这种方式可以在不显式定义子类的情况下快速创建一个类的子类并传递给方法实例化抽象类或者接口当然其实大部分时间在创建抽象类实例时都用的是成员内部类成员内部类定义在外部类的成员位置并且没有修饰可以直接访问外部类的所有成员包含私有的可以添加任意访问修饰符默认因为它的地位就是一个成员如果外部类和成员内部类成员重名默认遵守就近原则假如只想访问外部类的那个成员使用外部类名成员变量名假如成员变量不是静态的那么就是必须的访问基本语法作用域和外部类的其他成员一样为整个类体在外部类成员方法中创建成员内部类对象再调用方法外部其他类使用成员内部类的两种方法第一种相当于把当作的成员第二种在外部类中编写一个方法可以返回对象该对象返回一个实例静态内部类静态内部类是定义在外部类的成员位置并且有修饰可以直接访问外部类的所有静态成员包括私有的但是不能直接访问非静态成员可以添加任意访问修饰符默认因为它的地位就是一个成员作用域同其他的成员一样为整个类体张三不能直接访问外部类的非静态成员外部类访问静态内部类创建对象再访问外部其他类访问静态内部类同成员内部类的两种方法假如满足访问权限注意静态内部类不需要外部类的实例来创建静态内部类可以直接通过外部类的类名来创建实例如果外部类和静态内部类成员重名默认遵守就近原则假如只想访问外部类的那个成员使用外部类名成员变量名因为静态内部类能访问的成员变量只能是静态的访问张三李四枚举与注解枚举假如我们创建一个季节类由常识可知季节对象有且仅有四个并且我们不希望有人改变它们那么用传统方法创建实例就无法满足此时利用枚举类解决自定义枚举类前面的情景其实说白了就是常量只不过这次的常量变成了常量对象所以这种类特点如下不需要提供方法因为枚举类对象通常为只读可以提供方法对枚举对象属性使用共同修饰实现底层优化枚举对象名与常量一样需要大写枚举对象根据需要也可以有多个属性春天万物复苏夏天酷热难耐秋天秋高气爽冬天银装素裹枚举类枚举类的基本语法春天万物复苏夏天酷热难耐秋天秋高气爽冬天银装素裹注意事项成员属性和常量定义语句顺序不能变当我们使用关键字开发一个枚举类时默认会继承类而且这个枚举类是类如果使用的是无参构造器可以只写名字然后啥也不加方法在使用关键字时会隐式继承类这样我们就可以使用类相关的方法方法名详细描述用于将传递的枚举类型的对象和枚举常量名称转换为对应的枚举常量得到当前枚举常量的名称可以重写来使得到的结果更易读在枚举类型中可以直接使用来比较两个枚举常量是否相等提供的这个方法也是直接使用来实现的它的存在是为了在和中使用注意是不可变的实现了来和保持一致它也是不可变的得到枚举常量所属枚举类型的对象可以用它来判断两个枚举常量是否属于同一个枚举类型得到当前枚举常量的名称建议优先使用得到当前枚举常量的次序编号从零开始枚举类型实现了接口这样就可以比较两个枚举常量的大小按照声明的顺序排列返回的是顺序值的差值枚举类型不能被子类实现克隆方法实现了一个仅抛出异常的不便使用细节使用关键字后就不能再继承其他类了因为会隐式继承类而是单继承机制枚举类与普通类一样可以实现接口如下形式常量就是枚举类的实例因此枚举类的方法要用常量来调用注解注解又被称为元数据用于修饰解释包类方法属性构造器局部变量等数据信息和注释一样注解不影响程序逻辑但注解可以被编译或运行相当于嵌入在代码中的补充信息在中注解的使用目的比较简单例如标记过时的功能忽略警告等在中的注解占据了更为重要的角色例如用来配置应用程序的任何切面代替旧版中所遗留的繁冗代码和配置等使用时要加上符号并把该当成一个修饰符使用用于修饰它支持的程序元素注解用于限定某个方法是重写父类方法该注解只能用于方法在继承抽象接口用过好多次没啥好讲的事实上不加程序照样可以构成正常的重写它的作用就是让编译器去检查该方法是否真的重写了父类的方法没有就报错注解用于表示某个程序元素类方法等已经过时用于新旧版本的升级与过渡修饰某个元素表示该元素已过时过时意思是不推荐使用不是不能使用注解用于抑制编译器警告作用范围与位置有关在什么之前范围就是什么例如你将它放在一个方法前作用范围就是一个方法类之前就是一个类的范围注解可以抑制多种类型的编译器警告可以将这些警告传入可以是数组以下是一些常见的警告类型抑制未经检查的操作警告例如使用原始类型的集合抑制使用已过时的类或方法的警告抑制缺少字段的警告抑制使用原始类型的警告抑制未使用的变量或方法的警告抑制语句中分支没有的警告抑制不安全的类型转换的警告抑制除以零的警告抑制块中没有返回的警告抑制所有警告四种元注解元注解即为修饰注解的注解元注解的种类指定注解作用范围三种指定注解的使用范围指定直接是否会在里体现子类会继承父类注解一般在里见得多例如常用注解的定义里异常基本概念在语言中将程序执行中发生的不正常情况称为异常语法错误和逻辑错误不是异常执行过程中所发生的异常事件可分为两类错误虚拟机无法解决的严重问题如系统内部错误资源耗尽等严重情况比如栈溢出和是严重错误程序会崩溃其它因编程错误或偶然的外在因素导致的一般性问题可以使用针对性的代码进行处理例如空指针访问试图读取不存在的文件网络连接中断等等分为两大类运行时异常和编译时异常的运行顺序如下源程序字节码文件在内存中加载运行类异常体系图常见的异常包含了编译时异常和运行时异常两类编译时异常是在编译阶段被检查的异常必须要进行处理而运行时异常是在运行时才可能发生的异常不强制要求处理运行时异常空指针异常当应用程序试图在需要对象的地方使用时抛出该异常数学运算异常数组下标越界异常老朋友不写了类型转换异常当试图将对象强制转换为不是实例的子类时抛出该异常向上转型向下转型因为本来就是类型的不行因为和没关系数字格式不正确异常当程序试图将字符串转换成一种数值类型但是该字符串不能转换为合适的格式时抛出该异常编译异常操作数据库时查询表可能发生异常操作文件时当操作一个不存在的文件时加载类而该类不存在时操作文件到文件末尾参数异常异常处理异常处理概念基本介绍异常处理就是当异常发生时对异常处理的方式异常处理分类可能有异常的代码捕获到异常一旦异常发生直接跳到下面的就不管了如果异常没有发生则顺序执行的代码块不会进入系统将异常封装成对象传递给这个对象可以替换为特定的对象如上面介绍过的编译异常和运行异常中的用于捕获特定异常也就是说我们甚至可以写多个来捕获不同的对象来分别进行不同的业务处理要求父类异常在前子类异常在后如果发生异常只会匹配一个得到异常对象后我们自己处理不管代码块是否有异常始终要执行可以放文件系统数据库等的关闭释放资源可以使用配合使用这种用法相当于没有捕获异常因此程序会直接崩溃其应用场景在于执行一段代码不管是否发生异常都必须实现某个业务逻辑一个小练习要求写一个程序在不输入数字时一直重复提醒用户直到输入正确为止如果一个方法中的语句执行时可能生成某种异常但是并不能确定如何处理则此方法应显式声明抛出异常表明该方法将不对这些异常进行处理而由该方法的调用者负责处理在方法声明中用语句以声明抛出异常的列表后面的异常类型可以是方法中产生的异常类型也可以是它的父类也可以是异常列表子类在重写父类的方法时对抛出异常的规定子类重写的方法所抛出的异常要么与父类抛出的一致要么是父类抛出异常类型的子类型在执行过程中如果有方法就相当于处理异常就不会再向上层了调用抛出编译异常的方法时必须处理该异常否则编译器会报错关键字用于显式地抛出一个异常通常用于方法体内用来抛出一个具体的异常实例语法格式年龄必须大于岁自定义异常当程序中出现了某些错误但该错误信息并没有在子类中描述处理这个时候可以自己设计异常类用于描述该错误信息步骤定义类自定义异常类名继承或者或如果继承属于编译异常如果继承属于运行异常一般继承这个例年龄不在范围内范围正确通过构造器设置返回信息和的对比意义位置后面跟的东西异常处理的一种方式方法声明处异常类型手动生成异常对象的关键字方法体中异常对象常用类你懂的就是一些常见的常用的类包装类包装类的基本概念概念针对八种基本数据类型对应的引用类型基本数据类型包装类和直接继承自其他六个包装类继承自以后的装箱基本类型包装类型与拆箱都是自动的底层调用的是方法包装类的转换包装类前提代码语句自动装箱包装类前提代码语句自动装箱构造器包装类的常用静态方法与属性返回最小值返回最大值判断是不是数字一般用来判断字符串是不是数字判断是不是字母判断是不是大写判断是不是小写判断是不是空格转成大写转成小写包装类注意事项这种方式实际上已经被逐步弃用了建议用当使用自动装箱将基本类型转换为对象时会对值在到范围内的整数进行缓存因此如果和的值在这个范围内它们会引用同一个缓存对象类类的基本概念对象用于保存字符串也就是一组字符序列字符串常量对象是用双引号括起的字符序列例如你好等字符串的字符使用字符编码一个字符不区分字母和汉字占两个字节类是类型不能被其他类继承类实现了接口可以串行化即可以在网络传输接口对象可以比较大小类是的有属性用于存放字符串内容是类型不可以修改地址而不是值类的常用构造器与对象创建常用构造器对象创建方式直接赋值调用构造器在内存里和包装类不一样如果用第一种方法它会先找常量池里有没有值一样的如果有就直接指向如果没有自己再一个新的如果用第二种它是先找常量池里有没有值一样的然后在堆中指向这个常量但是这个时候地址肯定不一样方法返回的是这个值在常量池中的地址字符串特性是一个类代表不可变的字符序列常量字符串是不可变的一个字符串对象一旦被分配其内容是不可变的以上语句实际上创建了两个字符串对象从又指向了此时编译器并不会创建个对象而是在底层优化判断创建的常量值是否有引用指向等价为所以只创建了个对象创建了一个执行执行执行最后其实是指向了对象池中类的常用方法区分大小写判断内容是否相等忽略大小写判断内容是否相等返回字符串长度返回该字符串在字符串中第一次出现的位置找不到返回返回该字符串在字符串中最后一次出现的位置找不到返回截取指定范围前闭后开字符串去除前后空格返回索引处字符注意不可以用这种方式转为大写转为小写拼接原有字符串后面将字符串里所有的替换为但是原字符串不会变分割字符串对于分割字符我们需要转义如注意返回的是字符串数组比较两个字符串的大小长度不一样字符一样返回长度差长度一样字符不一样长度不一样字符不一样返回字符差根据字符串中第一个不同字符的值差计算转换为字符数组可以直接把字符数组传到中格式化字符串常用于精度控制在中如果一个类没有重写方法那么该类的默认字符串表示形式是由类的方法提供的默认情况下方法返回一个字符串格式如下类名对象的哈希码的十六进制表示例如如果你有一个对象默认的方法可能会返回类似于的字符串类和类类类简介代表可变的字符序列可以对字符串内容进行增删很多方法相同但是可变长度的是一个容器的直接父类是实现了即可以串行化在父类中有属性这个属性不是放在堆里该数组存放字符串内容引出存放在堆中的是的不能被继承类与类的比较保存的是字符串常量里面的值不能更改每次类的更新实际上就是更改地址效率较低类保存的是字符串变量里面的值可以更改每次更新会实际上可以更新的内容不用每次更新地址效率极高实例化创建一个大小为的用于存放字符内容通过构造器指定的大小实际上大小为你规定的互相转换使用构造器参数不能为空会报空指针异常因为底层需要调用传入的那个字符串这样并不会改变本身使用方法传空也没关系会在底层转化为字符数组的方法使用构造器类的常用方法追加删除前闭后开替换前闭后开查找字符串第一次出现的索引找不到返回查找字符串最后一次一次出现的索引找不到返回在处插入后面的内容自动后移返回字符串长度类类简介一个可变的字符序列此类提供一个与兼容的但不保证同步不是线程安全的该类被设计用作的一个简易替换用在字符串缓冲区被单个线程使用的时候如果可能建议优先采用该类因为在大多数实现中它比要快在上的主要操作是和方法可重载这些方法以接受任意类型的数据是的继承了含属性字符串内容存在里实现了接口是可串行化的即可以网络传输可保存到文件常用方法和均代表可变的字符序列方法是一样的所以使用和一样的比较从效率看使用原则结论如果字符串存在大量的修改操作一般使用或如果字符串存在大量的修改操作并存在单线程的情况使用如果字符串存在大量的修改操作并存在多线程的情况使用如果字符串很少被修改并且被多个对象引用使用例如配置信息等类常用方法求绝对值求幂向上取整向下取整四舍五入求开方返回之间的随机数没有参数返回特定范围的随机数以为例求两者的最大值求两者的最小值类类在包中该类包含了一系列静态方法用于管理或操作数组返回数组的字符串形式顺序排序定制排序只能用于对象数组而不是基本类型数组要对基本类型数组进行排序你需要将其转换为包装类型数组如可以看到实际上是匿名内部类尖括号里是泛型后面再讲这里要注意返回类型如果不是就写一个判断来返回是中的一个接口用于定义对象的比较规则它通常用于排序操作例如通过或方法对集合进行排序接口包含一个方法该方法用于比较两个对象和方法的实现决定了排序的顺序底层实际上是二叉排序所以要差值如果返回负值表示小于从小到大排如果返回零表示等于如果返回正值表示大于从大到小排还可以自己仿照方法写一个其他的排序二叉查找某值返回该值的索引要求数组必须有序如果找不到就返回数组长度从数组中拷贝个元素到新数组后面如果不写参数就是拷贝个元素假如会抛出异常将非空数组中的所有元素都填充为其实空的也没关系啦只是这条语句过后数组还是空的比较两个数组元素是否一致长度也算返回类型在里也是可以直接输出的将数组转成集合集合一般这样用奥迪奔驰类系统类类的常见方法退出当前程序将数组从位置开始到的子序列复制到数组从位置到在底层调用一般使用返回当前时间距离的毫秒数运行垃圾回收机制类和类这两个类下属包应用场景适合保存比较大的整型常见方法加减乘除须知这些方法返回类型还是适合保存精度更高的浮点型加减乘除这些方法和一样注意使用时可能会抛出异常因为结果可能是无限循环小数解决方式指定精度即可增加参数在出现无限循环小数时就会保留与被除数相同的精度日期类分为三代第一代日期类类下属包可以精确到毫秒代表特定的瞬间的特定格式化解析输出首先是可以直接输出的但是输出的格式是国外的默认形式如果我们想要改变格式就需要用到一个下属类类在包内用于格式化和解析具体日期该类允许进行格式化日期文本解析文本日期和规范化用此类下属的方法解析类之后返回的类型实际上是这样一来就可以输出成我们想要的格式了年月日注意格式书写的时候那些等等字母不是随便写的大小写都有不同含义自己看吧还可以指定毫秒数输出时间返回自加上你输入的毫秒数时间这个参数是类型的用的是的方法可以把一个格式化的转成对应的但是得到的在输出时仍然是按照默认国外形式想转换还是用否则会抛出转换异常在转换时需要保证格式与的格式一样否则会抛出转换异常但是无论格式是否一样都需要在这里异常处理年月日年月日星期一第二代日期类类类来自包它是一个抽象类所以在实例化时只能用是啥的所有信息全都储存在字段里所以我们要想输出特定的年月日只需提取特定字段输出即可当然直接输出也没关系只是会把的所有信息以及所有字段全部直接输出数量非常多而且没有什么格式不美观注意类中的字段如等是静态常量它们只是用来表示特定的日历字段的标识符这些字段本身并不包含具体的日期或时间值要获取具体的日期或时间值需要一个对象因为这些值是与特定的实例相关联的然后再用方法就可以调用这些静态字段啦年月月份默认从开始算所以要加一来复习一下怎么用任何基本类型最后都会变成所以需要括号括住先算加法再默认转成日小时字段是小时制想要小时制可以输出字段分钟秒输出年月日没有专门的格式化方式需要自己组合显示好消息是比较灵活第三代日期类前两代日期类的不足分析类在包中在中被引入但是它的大多数方法已经在中随着的隐忍而被弃用了而类也存在问题可变性像日期和时间这样的类应该是不可变的偏移性中的年份是从开始的而月份都从开始格式化只有可以格式化不行此外它们也不是线程安全的不能处理闰秒每隔两天多出一秒等引入的第三代日期类以下类都在包下日期年月日时间时分秒日期时间年月日时分秒常用方法返回当前时间的全部信息返回年月数字版是整数值月英文版是枚举类型日小时分钟秒判断是否是闰年增加某时间后减少某时间后格式日期类类似于年月日小时分钟秒其中的字母格式也是需要自己在里看时间戳下属包是的现代替代品提供了更好的和更高的精度可以用来表示一个时间戳通常用于记录事件发生的精确时间通过静态方法获取表示当前时间戳的对象通过方法可将转成通过的可以吧转为对象集合在前面实际上已经简单地提过集合了可以自行翻看学习记录集合就是数学中的集合的概念所有的元素都具有唯一的值元素在其中没有顺序在中集合可以动态保存任意多个对象并提供了一系列方便的操作对象的方法集合框架体系单列集合双列集合接口接口实现类的特点实现子类可以存放多个元素每个元素可以是有些的实现类可以存放重复元素有些不可以有些的实现类有些有序有些无序接口没有直接的实现子类是通过它的接口和来实现的常用方法添加单个元素删除指定元素查找元素是否存在获取元素个数判断是否为空清空添加多个元素查找多个元素是否存在删除多个元素遍历方式迭代器对象称为迭代器主要用于遍历集合中的元素它的整个使用方式与指针类似所有实现了接口的集合类都有一个方法用以返回一个实现了接口的对象即可以返回一个迭代器仅用于遍历集合本身并不存放对象方法如果仍有元素可以迭代则返回集合中这个位置存放元素的类型返回迭代的下一个元素从集合中移除迭代器返回的最后一个元素可选操作三国演义红楼梦小李飞刀遍历当退出循环后这时迭代器指向了最后的元素如果希望再次像这样遍历需要重置迭代器增强循环三国演义红楼梦小李飞刀省略其实就是但是遍历元素变成了集合里的对象类型也可以理解成简化版迭代器接口接口继承自表示一个有序的集合允许重复元素每个元素都有对应整数型索引常用实现类包括和常用方法包括获取指定位置的元素替换指定位置的元素在指定位置插入元素删除指定位置的元素返回元素第一次出现的位置返回元素最后一次出现的位置返回从到的子集合是一个可调整大小的数组实现适用于频繁的随机访问和迭代操作底层是用数组实现的基本等同于线程不安全但是效率高在多线程情况下不建议使用常用方法在列表末尾添加元素在指定位置插入元素获取指定位置的元素替换指定位置的元素移除指定位置的元素返回列表中的元素数量清空列表中的所有元素判断列表是否包含指定元素的底层扩容机制是通过动态数组实现的当中的元素数量超过其当前容量时它会自动扩容具体的扩容机制如下初始容量在创建时可以指定初始容量如果没有指定则使用默认容量通常是扩容条件当添加新元素时如果当前数组已满即元素数量等于数组容量则需要扩容扩容大小扩容时会创建一个新的数组其容量通常是旧数组容量的倍在某些实现中可能是倍然后将旧数组中的元素复制到新数组中复制元素将旧数组中的元素复制到新数组中并将新数组的引用赋值给的内部数组引用这种扩容机制确保了能够动态调整其大小以适应不断增加的元素同时尽量减少扩容操作的频率是一个双向链表实现适用于频繁的插入和删除操作常用方法在列表末尾添加元素在指定位置插入元素在列表开头插入元素在列表末尾插入元素获取指定位置的元素获取列表中的第一个元素获取列表中的最后一个元素移除指定位置的元素移除列表中的第一个元素移除列表中的最后一个元素返回列表中的元素数量清空列表中的所有元素判断列表是否包含指定元素的底层机制是基于双向链表实现的双向链表是一种数据结构其中每个节点包含三个部分一个指向前一个节点的引用一个存储数据的元素以及一个指向下一个节点的引用的底层机制如下节点结构每个节点包含三个部分指向前一个节点的引用存储的数据元素指向下一个节点的引用头节点和尾节点维护对头节点和尾节点的引用以便快速访问列表的开头和结尾插入操作在列表开头插入元素时创建一个新节点并将其引用指向当前的头节点同时更新头节点的引用指向新节点在列表末尾插入元素时创建一个新节点并将其引用指向当前的尾节点同时更新尾节点的引用指向新节点在指定位置插入元素时遍历链表找到指定位置的节点调整相邻节点的和引用以插入新节点删除操作删除头节点时将头节点的引用更新为新的头节点并将新头节点的引用设为删除尾节点时将尾节点的引用更新为新的尾节点并将新尾节点的引用设为删除指定位置的节点时遍历链表找到指定位置的节点调整相邻节点的和引用以移除该节点访问操作通过遍历链表找到指定位置的节点然后返回该节点的元素与的比较如果改查的操作多选增删操作多选一般来讲在程序中大部分都是查询所以大部分情况下选实际情况请根据需求灵活选择是一个同步的动态数组实现适用于需要线程安全的场景常用方法在列表末尾添加元素在指定位置插入元素获取指定位置的元素替换指定位置的元素移除指定位置的元素返回列表中的元素数量清空列表中的所有元素判断列表是否包含指定元素返回向量的当前容量确保向量至少具有指定的最小容量的底层扩容机制与类似但有一些不同之处是一个同步的动态数组实现适用于需要线程安全的场景其扩容机制如下初始容量在创建时可以指定初始容量如果没有指定则使用默认容量通常是扩容条件当添加新元素时如果当前数组已满即元素数量等于数组容量则需要扩容扩容大小扩容时会创建一个新的数组其容量通常是旧数组容量的倍这个倍数可以通过构造函数指定的参数来改变如果为则每次扩容时容量加倍否则每次扩容时容量增加的值复制元素将旧数组中的元素复制到新数组中并将新数组的引用赋值给的内部数组引用接口接口继承自表示一个不包含重复元素的集合常用实现类包括和常用方法与接口类似但不允许重复元素在遍历上可以和一样使用迭代器和增强循环但是不能使用索引直接访问接口对象存放顺序是无序的即添加顺序和取出顺序不一致但是仍然是固定的常用方法将指定的元素添加到集合中如果该元素尚不存在从集合中移除指定的元素如果存在判断集合中是否包含指定的元素返回集合中的元素数量判断集合是否为空清空集合中的所有元素返回集合中元素的迭代器将指定集合中的所有元素添加到当前集合中如果这些元素尚不存在从当前集合中移除指定集合中包含的所有元素仅保留当前集合中那些包含在指定集合中的元素将集合中的元素转换为数组是基于哈希表实现的接口的实现类它不保证集合的迭代顺序特别是它不保证该顺序恒久不变不保证存放顺序和取出顺序一致可以存放值但是只能有一个不允许重复元素其内部使用一个来存储元素的键是元素本身而值是一个固定的对象当你向添加一个元素时它会调用元素的方法来计算哈希值并将该哈希值用于确定元素在哈希表中的位置如果两个元素的哈希值相同即它们的方法返回相同的值则会进一步调用它们的方法来检查它们是否相等如果两个元素相等则新的元素不会被添加到中从而保证了中没有重复的元素常用方法将指定的元素添加到集合中如果该元素尚不存在从集合中移除指定的元素如果存在判断集合中是否包含指定的元素返回集合中的元素数量判断集合是否为空清空集合中的所有元素返回在此集合的元素上进行迭代的迭代器在存放时假如是常量底层就会发现但是如果是对象的话因为不同所以不会被认为是同一个元素重点那么假设我不想再加入对象时因为而让相同的元素加入集合该怎么办呢答案是在这个对象的类里重写和方法控制在什么情况下两个对象被认为是相同的它定义了对象相等的逻辑方法利用保证相等对象的哈希码相同它生成一个整数值用于在哈希表等数据结构中快速查找和存储对象是的子类具有可预知的迭代顺序它底层是维护一个双向链表来记录元素的插入顺序根据元素的值来决定元素的存储位置同时使用链表维护元素的次序这使得元素看起来是以插入顺序保存的不允许添加重复元素常用方法将指定的元素添加到集合中如果该元素尚不存在从集合中移除指定的元素如果存在判断集合中是否包含指定的元素返回集合中的元素数量判断集合是否为空清空集合中的所有元素返回在此集合的元素上进行迭代的迭代器是基于红黑树实现的接口的实现类它保证集合中的元素是有序的常用方法将指定的元素添加到集合中如果该元素尚不存在从集合中移除指定的元素如果存在判断集合中是否包含指定的元素返回集合中的元素数量判断集合是否为空清空集合中的所有元素返回在此集合的元素上进行迭代的迭代器返回当前集合中的第一个最小的元素返回当前集合中的最后一个最大的元素返回此集合部分元素的视图范围从包括到不包括接口表示一个键值对映射中的和可以是任何引用类型的数据会封装到对象中中的不允许重复假如重复了就相当于替换原因和一样但是可以重复的和可以为遍历方法先取出所有再通过取出对应的增强循环最常用的浮士德李箱堂吉诃德良秀维吉利乌斯迭代器浮士德李箱堂吉诃德良秀维吉利乌斯只将所有的取出增强循环浮士德李箱堂吉诃德良秀维吉利乌斯迭代器浮士德李箱堂吉诃德良秀维吉利乌斯通过得到键值对增强循环浮士德李箱堂吉诃德良秀维吉利乌斯将键值对转为向下转型迭代器浮士德李箱堂吉诃德良秀维吉利乌斯实际返回的是类型将键值对转为向下转型常用基于哈希表实现允许键和值无序不保证顺序适合快速查找插入和删除操作当你使用存储键值对时每个键值对实际上是存储在一个内部类中是的一个静态内部类它实现了接口每个对象包含一个键一个值一个哈希值以及指向下一个节点的引用用于处理哈希冲突时的链表结构当你向中添加一个键值对时会创建一个对象来存储这个键值对并将其放入适当的桶中如果发生哈希冲突即多个键的哈希值相同这些对象会以链表的形式链接在一起常用方法添加键值对获取指定键对应的值删除指定键对应的键值对获取元素个数判断元素个数是否为零清空判断是否包含指定键判断是否包含指定值返回所有键的集合返回所有值的集合返回所有键值对的集合是一种基于哈希表的数据结构它实现了接口在中是一个线程安全的集合类适用于多线程环境关键特性线程安全的所有方法都是同步的因此它是线程安全的适用于多线程环境不允许键和值不允许存储键或值如果尝试插入键或值会抛出无序不保证元素的顺序键值对的顺序可能会随着插入和删除操作而变化基于哈希表实现使用哈希表来存储键值对具有较快的查找插入和删除操作常用方法将指定的键和值插入到哈希表中如果哈希表中已经存在该键则更新其对应的值返回指定键所对应的值如果哈希表中不包含该键则返回从哈希表中移除指定键及其对应的值判断哈希表中是否包含指定的键判断哈希表中是否包含指定的值返回哈希表中键值对的数量判断哈希表是否为空底层机制底层有数组初始化大小为扩容机制触发扩容当哈希表中的键值对数量达到或超过临界值哈希表在进行扩容之前所能容纳的最大键值对数量时哈希表会进行扩容创建新的哈希表扩容时哈希表会创建一个新的更大的哈希表新的哈希表的容量通常是当前容量的两倍例如如果当前容量为那么扩容后的新容量为重新计算哈希码所有现有的键值对需要重新计算哈希码并根据新的容量重新分配到新的哈希表中这是因为哈希表的容量变化会影响哈希码的映射位置重新分配键值对将旧哈希表中的所有键值对复制到新的哈希表中由于容量增加哈希冲突的概率会降低从而提高哈希表的性能基本介绍类继承自类并且实现了接口也使用键值对形式来保存数据具有哈希表的所有特性键和值都是字符串类中的键和值都是字符串类型还可以用于从文件中加载数据到类对象并进行读取和修改说明工作后文件通常作为配置文件用于存储配置信息常用方法用指定的键在此属性列表中搜索属性调用方法并使用字符串类型的键和值删除该键对应的键值对将此属性列表键和元素对以适合人阅读的形式打印到指定的输出流从输入流中读取属性列表键和元素对将此属性列表键和元素对写入输出流是集合框架中的一个实现了接口的类它基于红黑树实现提供了有序的键值对存储并且保证所有的键值对按照键的自然顺序或通过提供的比较器顺序排序关键特性有序性中的键值对是按键的自然顺序或通过提供的比较器顺序排序的基于红黑树实现使用红黑树数据结构来存储键值对保证了基本操作如插入删除查找的时间复杂度为不允许键不允许存储键但允许存储值线程不安全不是线程安全的如果需要在多线程环境中使用可以使用方法来获取线程安全的常用方法将指定的键和值插入到映射中如果映射中已经存在该键则更新其对应的值返回指定键所对应的值如果映射中不包含该键则返回从映射中移除指定键及其对应的值返回映射中当前第一个最小的键返回映射中当前最后一个最大的键返回部分映射其键的范围从包括到不包括返回部分映射其键的范围小于返回部分映射其键的范围大于等于工具类是提供的一个实用工具类包含了许多静态方法用于操作或返回集合类提供了对集合进行排序搜索同步化等操作的便捷方法常用方法排序对列表进行自然排序对列表进行自定义排序搜索使用二分搜索法搜索列表中的指定对象使用二分搜索法搜索列表中的指定对象使用自定义比较器同步化返回指定列表的同步线程安全列表返回指定映射的同步线程安全映射返回指定集合的同步线程安全集合不可变集合返回指定列表的不可修改视图返回指定映射的不可修改视图返回指定集合的不可修改视图其他实用方法反转指定列表中元素的顺序使用默认随机源随机排列指定列表中的元素用指定元素替换指定列表中的所有元素将源列表中的所有元素复制到目标列表中根据元素的自然顺序返回给定集合中的最小元素根据元素的自然顺序返回给定集合中的最大元素返回指定集合中指定元素的出现次数',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-24 22:31:57',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/head.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼的图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼的图床"/><span class="back-menu-item-text">安知鱼的图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">ZUTA的观测站</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">编程语言<sup>2</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3%E5%AD%A6%E7%A7%91/" style="font-size: 1.05rem;">计算机相关学科<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>编程语言</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Java后日谈</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-11-08T14:19:06.000Z" title="发表于 2024-11-08 22:19:06">2024-11-08</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-11-24T14:31:57.671Z" title="更新于 2024-11-24 22:31:57">2024-11-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">19.5k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>70分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="Java后日谈"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/article_background2.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://zuta39.github.io/2024/11/08/JavaTalkLater/"><header><a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" tabindex="-1" itemprop="url">编程语言</a><h1 id="CrawlerTitle" itemprop="name headline">Java后日谈</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ZUTA39</span><time itemprop="dateCreated datePublished" datetime="2024-11-08T14:19:06.000Z" title="发表于 2024-11-08 22:19:06">2024-11-08</time><time itemprop="dateCreated datePublished" datetime="2024-11-24T14:31:57.671Z" title="更新于 2024-11-24 22:31:57">2024-11-24</time></header><p>这一部分主要是深入的知识，笔记来源于韩顺平老师的Java课程。</p>
<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><h3 id="关于main方法的更多细节"><a href="#关于main方法的更多细节" class="headerlink" title="关于main方法的更多细节"></a>关于main方法的更多细节</h3><ol>
<li>运行<br>Java虚拟机负责运行主方法。</li>
<li>参数<br> String[] args 这一参数由程序运行时传入，传入的内容也由传入时决定。</li>
<li>静态的（static）<br>main方法静态的特点与一般方法的静态相同。即：只能直接调用同为静态的属性或方法（限定在同一个类中），如果想调用非静态的只能先创建实例再调用。</li>
</ol>
<p>未完成！！</p>
<h3 id="代码块（-）"><a href="#代码块（-）" class="headerlink" title="代码块（*）"></a>代码块（*）</h3><p>即是可重复调用的构造器代码（构造器的补充），由花括号包围。<br>无论构造器有多少重载，都会&#x3D;&#x3D;先调用代码块里的内容，再调用构造器&#x3D;&#x3D;。</p>
<p>代码块使用 <em><strong>注意事项</strong></em>：</p>
<ol>
<li>如果代码块前有static修饰，作用就是对类进行初始化，随着 <em><strong>类的加载</strong></em> 而执行。<ul>
<li>类什么时候加载？<ul>
<li>创建对象实例时。（new）</li>
<li>创建子类对象实例时，父类也会被加载。</li>
<li>使用类的静态成员时。</li>
</ul>
</li>
</ul>
</li>
<li>普通代码块在 <em><strong>创建对象实例</strong></em> 时会被隐式调用，每被创建一次就调用一次。在使用类的静态成员时，普通代码块不会被执行。<ul>
<li>调用时的顺序？<ul>
<li>在创建一个对象时，在类中的调用顺序是？<br> 先调用静态代码块与静态属性（都有就按定义顺序来）<br> 再调用普通代码块与普通属性。（同上）<br> 最后调用方法。</li>
<li>在继承时呢？<br> 构造器的前面其实隐含了super()和调用普通代码块。静态代码块，属性初始化在类加载时就已经执行完毕了。因此继承先于构造器与普通代码块执行。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>静态代码块只能直接调用静态成员，普通代码块可以调用任意成员。</p>
<p>创建一个子类对象时，整体的调用顺序如下：</p>
<ol>
<li>父类静态代码块与静态属性</li>
<li>子类静态代码块与静态属性</li>
<li>父类普通代码块与普通属性，构造方法。</li>
<li>子类普通代码块与普通属性，构造方法。</li>
</ol>
<h3 id="静态方法与属性的使用–单例设计模式"><a href="#静态方法与属性的使用–单例设计模式" class="headerlink" title="静态方法与属性的使用–单例设计模式"></a>静态方法与属性的使用–单例设计模式</h3><p>所谓单例模式，就是采用一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。<br>适用于单一特点的类。</p>
<p>如何保证只有一个实例呢？</p>
<ul>
<li><p>饿汉式（由于对象是static的，所以无论有没有使用它，都会在类加载时创建）</p>
<ol>
<li>将构造器私有化。</li>
<li>在类的内部直接创建对象（static）。</li>
<li>提供一个公共的static（因为要调用static对象，所以得是static属性）方法，返回这个对象。</li>
</ol>
</li>
<li><p>懒汉式（不用就不创建）</p>
<ol>
<li>将构造器私有化</li>
<li>定义一个static对象作为成员属性（不是new一个！！）</li>
<li>提供一个公共的static方法，并附上判断，如果2中的对象确实为空，就将这个对象new出来。（这样就可以保证只有在这个方法被调用时对象才会被创建，后面再调用也还是这同一个对象）</li>
</ol>
</li>
</ul>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>final关键字可以修饰类，属性，方法和局部变量</p>
<blockquote>
<p>局部变量是指在方法、构造方法或代码块中定义的变量。它们的作用域仅限于定义它们的方法、构造方法或代码块内。当方法、构造方法或代码块执行完毕后，局部变量就会被销毁。局部变量不能有访问修饰符（如public、private等），因为它们的作用范围仅限于方法内部。</p>
</blockquote>
<p>在以下情况会使用final：</p>
<ol>
<li>不希望类被继承</li>
<li>不希望父类某个方法被子类覆盖&#x2F;重写(override)</li>
<li><em><strong>不希望某个属性值被修改（常量）</strong></em></li>
<li>不希望某个局部变量被修改</li>
</ol>
<h4 id="注意事项与细节讨论"><a href="#注意事项与细节讨论" class="headerlink" title="注意事项与细节讨论"></a>注意事项与细节讨论</h4><ol>
<li>final修饰的属性称为常量，命名格式为大写字母+下划线，常量 <em><strong>必须初始化</strong></em></li>
<li>常量可在以下位置初始化：<ul>
<li>定义时</li>
<li>在构造器中</li>
<li>在代码块中</li>
</ul>
</li>
<li>如果final修饰的属性是static（静态的），那么初始化的位置 <em><strong>只能</strong></em> 是：<ul>
<li>定义时</li>
<li>在静态代码块中， <em><strong>不能在构造器中赋值！！</strong></em></li>
</ul>
</li>
<li>final类只是不能继承，其他的事还是可以干的。</li>
</ol>
<h3 id="关于继承中的super"><a href="#关于继承中的super" class="headerlink" title="关于继承中的super"></a>关于继承中的super</h3><p>super 关键字在 Java 中有以下几种主要用法：</p>
<ol>
<li><p>调用父类的构造方法：</p>
<ul>
<li>在子类的构造方法中，可以使用 super() 调用父类的构造方法。&#x3D;&#x3D;必须是构造方法中的第一条语句&#x3D;&#x3D;。</li>
<li>如果父类有参数化的构造方法，可以使用 super(参数列表) 调用相应的构造方法。</li>
</ul>
</li>
<li><p>访问父类的成员变量：</p>
<ul>
<li>当子类和父类有同名的成员变量时，可以使用 super.变量名 来访问父类的成员变量。</li>
</ul>
</li>
<li><p>调用父类的方法：</p>
<ul>
<li>当子类重写了父类的方法时，可以使用 super.方法名() 来调用父类的版本。</li>
</ul>
</li>
</ol>
<p>下面是一个示例代码，展示了 super 的这些用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    Parent() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent Constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Parent(<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent Constructor with parameter: &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent display method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    Child() &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 调用父类的无参构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Child Constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Child(<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="built_in">super</span>(x); <span class="comment">// 调用父类的有参构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Child Constructor with parameter: &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.display(); <span class="comment">// 调用父类的 display 方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Child display method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child x: &quot;</span> + x);</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent x: &quot;</span> + <span class="built_in">super</span>.x); <span class="comment">// 访问父类的成员变量 x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Child</span> <span class="variable">child1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        child1.display();</span><br><span class="line">        child1.show();</span><br><span class="line"></span><br><span class="line">        <span class="type">Child</span> <span class="variable">child2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">30</span>);</span><br><span class="line">        child2.display();</span><br><span class="line">        child2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象与接口"><a href="#抽象与接口" class="headerlink" title="抽象与接口"></a>抽象与接口</h2><h3 id="抽象（abstract）"><a href="#抽象（abstract）" class="headerlink" title="抽象（abstract）"></a>抽象（abstract）</h3><h4 id="抽象基本介绍"><a href="#抽象基本介绍" class="headerlink" title="抽象基本介绍"></a>抽象基本介绍</h4><p>当父类的某些方法需要声明，但是又不确定如何实现时（即父类方法不确定），可以将其声明为抽象方法（没有实现，没有方法体的方法），这个类也就是抽象类。</p>
<p>一般来说，&#x3D;&#x3D;抽象类会被继承&#x3D;&#x3D;，由其子类来实现抽象方法。</p>
<h4 id="抽象类的注意事项与细节"><a href="#抽象类的注意事项与细节" class="headerlink" title="抽象类的注意事项与细节"></a>抽象类的注意事项与细节</h4><ol>
<li><p>抽象类&#x3D;&#x3D;不能&#x3D;&#x3D;被直接实例化（不绝对）。<br>注意，分为以下两种情况：</p>
<ol>
<li><p>系统提供的抽象类：通常会提供静态工厂方法（如 getInstance()）来返回该抽象类的具体实现类的实例。例如，Calendar.getInstance() 返回一个 Calendar 的具体实现类实例。</p>
</li>
<li><p>自定义的抽象类：你需要定义一个具体的子类来继承该抽象类，然后实例化这个子类。</p>
</li>
</ol>
</li>
<li><p>抽象类可以没有abstract方法，可以有任意成员。</p>
</li>
<li><p>一旦包含abstract方法，这个类必须声明为abstract。</p>
</li>
<li><p>abstract只能修饰类和方法，不能修饰属性和其他的。</p>
</li>
<li><p>抽象方法不能使用private、final和static修饰，因为它们与重写矛盾。（即抽象类只能是public）</p>
</li>
</ol>
<p>&#x3D;&#x3D;抽象可以说是继承的拓展版&#x3D;&#x3D;</p>
<h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h3><h4 id="接口基本介绍"><a href="#接口基本介绍" class="headerlink" title="接口基本介绍"></a>接口基本介绍</h4><p>接口就是给出一些没有实现的方法，封装到一起，等某个类要使用时，再根据具体情况具体实现这些方法。</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123; <span class="comment">// 接口类</span></span><br><span class="line">   <span class="comment">// 属性</span></span><br><span class="line">   <span class="comment">// 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123; <span class="comment">//使用接口的类</span></span><br><span class="line">   <span class="comment">// 属性1</span></span><br><span class="line">   <span class="comment">// 属性2</span></span><br><span class="line">   <span class="comment">// 必须实现的接口（A）的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口主要用于规范化一些类。</p>
<h4 id="接口注意事项"><a href="#接口注意事项" class="headerlink" title="接口注意事项"></a>接口注意事项</h4><ol>
<li><p>接口默认为抽象类，不需要特意加abstract。因此，抽象类适用的它也适用。</p>
</li>
<li><p>接口中的所有方法默认为public。</p>
</li>
<li><p>抽象类实现接口，可以不用实现接口的方法。</p>
</li>
<li><p>一个类同时可以实现多个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">B</span>, C &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口中的属性实际上是final的。（而且是public static final）</p>
</li>
<li><p>由于接口中的属性实际上是static的，所以可以直接用接口名访问。</p>
</li>
<li><p>接口不可以继承其他类，但是可以继承多个别的接口。</p>
</li>
<li><p>interface 不能使用 implements 关键字来实现另一个接口。相反，接口可以通过 extends 关键字来继承其他接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>, C &#123;</span><br><span class="line">   <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口只能是public或默认（protected）的。</p>
</li>
</ol>
<h4 id="继承与接口的比较"><a href="#继承与接口的比较" class="headerlink" title="继承与接口的比较"></a>继承与接口的比较</h4><p>当子类继承了父类，就自动拥有父类的功能。如果子类需要拓展功能，就可以通过实现接口来拓展。<br>简单来讲就是，实现接口是对Java单继承机制的一种补充。</p>
<p>继承的价值主要在于：解决代码的复用性和可维护性。<br>接口的价值主要在于：设计好各种规范（方法），让其它类去实现，更加灵活。</p>
<p>继承满足 is-a 的关系，而接口满足 like-a的关系。</p>
<p>接口在一定程度上实现了代码解耦。（即：接口规范性 + 动态绑定）</p>
<h4 id="接口的多态"><a href="#接口的多态" class="headerlink" title="接口的多态"></a>接口的多态</h4><p>如果B接口继承了A接口，而C类实现了B接口，那么实际上就相当于C类也实现了A接口。这就是所谓的接口多态传递。</p>
<p>当接口作为方法参数时，可以将实现了这个接口的类的实例传递给它。这是因为接口类型的参数可以接受任何实现该接口的类的实例。(类似继承的多态)</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="内部类的基本介绍"><a href="#内部类的基本介绍" class="headerlink" title="内部类的基本介绍"></a>内部类的基本介绍</h3><p>一个类的内部又完整地嵌套了另一个类结构。被嵌套的那个类称为 <em><strong>内部类（inner class）</strong></em>。嵌套其他类的类称为 <em><strong>外部类（outer class）</strong></em> 。&#x3D;&#x3D;内部类&#x3D;&#x3D;的最大特点就是&#x3D;&#x3D;可以直接访问私有属性&#x3D;&#x3D;，并且可以体现类与类之间的包含关系。</p>
<p>内部类是类的五大成员之一。</p>
<blockquote>
<p>类的五大成员有：属性、方法、构造器、代码块、内部类。</p>
</blockquote>
<p>基本语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123; <span class="comment">// 外部类</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Inner</span> &#123; <span class="comment">// 内部类</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span> &#123; <span class="comment">// 外部其他类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h3><ul>
<li>定义在外部类局部位置上（比如方法内或代码块内）：<ol>
<li>局部内部类（有类名）</li>
<li>&#x3D;&#x3D;匿名内部类&#x3D;&#x3D;（无类名）</li>
</ol>
</li>
<li>定义在外部类成员位置上：<ol>
<li>成员内部类（无static修饰）</li>
<li>静态内部类（使用static修饰）</li>
</ol>
</li>
</ul>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><ol>
<li>局部内部类本质仍然是一个类，与普通类区别在于它可以直接访问外部类的所有成员，包括私有的。</li>
<li>局部内部类不能添加访问修饰符，因为它与局部变量地位相同，但是可以加final关键字【<a href="#final%E5%85%B3%E9%94%AE%E5%AD%97">局部变量是什么？</a>】</li>
<li>局部内部类作用域仅仅在定义它的方法或代码块中。（与局部变量相同）</li>
<li>局部内部类访问外部类的成员可以直接访问；外部类访问局部内部类的成员需要先创建对象再访问（在作用域内）</li>
<li>如果外部类和局部内部类成员重名，默认遵守就近原则。假如只想访问外部类的那个成员，使用 【外部类名】.this.【成员变量名】（假如成员变量不是静态的，那么this就是必须的） 访问。<blockquote>
<p>【外部类名】.this本质就是外部类的对象，即哪个对象调用了包含这个局部内部类的方法，【外部类名】.this.就是哪个对象。</p>
</blockquote>
</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">outerField</span> <span class="operator">=</span> <span class="string">&quot;Outer Field&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">localVar</span> <span class="operator">=</span> <span class="string">&quot;Local Variable&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInner</span> &#123;</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 访问外部类的成员</span></span><br><span class="line">                System.out.println(outerField);</span><br><span class="line">                <span class="comment">// 访问局部变量</span></span><br><span class="line">                System.out.println(localVar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalInner</span> <span class="variable">localInner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalInner</span>(); <span class="comment">// 需要在外部类定义这个局部内部类的方法中实例化局部内部类！！</span></span><br><span class="line">        localInner.innerMethod(); <span class="comment">// 因为实例化以后才能使用局部内部类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.outerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相应的应用场景不太多。</p>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a><strong>匿名内部类</strong></h4><h5 id="匿名内部类的基本语法"><a href="#匿名内部类的基本语法" class="headerlink" title="匿名内部类的基本语法"></a>匿名内部类的基本语法</h5><ol>
<li>本质是类，内部类。</li>
<li>该类没有名字（其实也不是没有，只不过是系统取的名字而且被隐藏了）</li>
<li>该类同时还是一个对象。</li>
<li>可以 <em><strong>直接访问</strong></em> 外部类的所有成员，包括私有的。</li>
<li>不能添加访问修饰符，因为它的地位就是一个局部变量。</li>
<li>作用域：仅仅在定义它的方法或代码中。</li>
<li>外部其他类不能访问匿名内部类。</li>
<li>如果外部类和匿名内部类成员<strong>重名</strong>，默认遵守<strong>就近原则</strong>。假如只想访问外部类的那个成员，使用 【外部类名】.this.【成员变量名】（假如成员变量不是静态的，那么this就是必须的） 访问。</li>
</ol>
<p>基本语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="comment">/*类或接口*/</span>(<span class="comment">/*参数列表*/</span>)  &#123;</span><br><span class="line">   <span class="comment">// 类体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>基于抽象类与接口的匿名内部类<br> 需求：想使用某接口，但是这个类只是使用一次。【相当于是使用接口】</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>() &#123;</span><br><span class="line">         <span class="comment">// 实现接口中的方法</span></span><br><span class="line">         <span class="comment">// a 的编译类型是 A</span></span><br><span class="line">         <span class="comment">// a 的运行类型是 B??（系统起的名字，即内部类的名称）</span></span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于类的内部类<br> 需求：想使用某类，但是这个类只是使用一次。【相当于是使用继承】</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>() &#123;</span><br><span class="line">         <span class="comment">// 可以进行继承的所有操作</span></span><br><span class="line">         <span class="comment">// a 的编译类型是 A</span></span><br><span class="line">         <span class="comment">// a 的运行类型是 B??（系统起的名字，即内部类的名称）</span></span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 会继承了，抽象也是一样的道理。</p>
</li>
</ul>
<p>注：由于匿名内部类兼有类和对象的特点，以下两种调用方法的方式都可以运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 省略</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*第一种*/</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">A</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="comment">// 重写父类方法</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="comment">// 省略</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;.hi();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*第二种*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="comment">// 重写父类方法</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="comment">// 省略</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">         a.hi();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ol>
<li><p>&#x3D;&#x3D;当作实参直接传递&#x3D;&#x3D;，简洁高效。（例如创建 <em><strong>接口类型</strong></em> 的匿名内部类，传递给其他方法，不用专门写一个类））</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(A a)</span> &#123;</span><br><span class="line">      a.hi();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 以参数方式使用匿名内部类实现接口</span></span><br><span class="line">      b.f(<span class="keyword">new</span> <span class="title class_">A</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hi from Anonymous Interface A&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这个程序时，输出将是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hi from Anonymous A  </span><br></pre></td></tr></table></figure>

<p>这表明匿名内部类的 hi() 方法被调用了。通过这种方式，&#x3D;&#x3D;可以在不显式定义子类的情况下，快速创建一个类的子类并传递给方法&#x3D;&#x3D;。</p>
</li>
<li><p>实例化抽象类或者接口。<br>当然，其实大部分时间在创建抽象类实例时都用的是getinstance()。</p>
</li>
</ol>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>成员内部类定义在外部类的成员位置，并且没有static修饰。</p>
<ol>
<li><p>可以直接访问外部类的所有成员，包含私有的。</p>
</li>
<li><p>可以添加任意访问修饰符（public, protected, 默认, private），因为它的地位就是一个成员。</p>
</li>
<li><p>如果外部类和成员内部类成员&#x3D;&#x3D;重名&#x3D;&#x3D;，默认遵守&#x3D;&#x3D;就近原则&#x3D;&#x3D;。假如只想访问外部类的那个成员，使用 【外部类名】.this.【成员变量名】（假如成员变量不是静态的，那么this就是必须的） 访问。</p>
</li>
<li><p>基本语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">B</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">      o.t();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">t</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">      c.say();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用域<br>和外部类的其他成员一样，为整个类体。在外部类成员方法中创建成员内部类对象，再调用方法。</p>
</li>
<li><p>外部其他类使用成员内部类的两种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种,相当于把new Inner()当作Outer的成员</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Program</span> &#123;</span><br><span class="line">   <span class="type">Outer</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line"></span><br><span class="line">   Outer.<span class="type">Inner</span> <span class="variable">i1</span> <span class="operator">=</span> o1.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;n1 = &quot;</span> + n1 + <span class="string">&quot;\nn2 = &quot;</span> + n2);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">t</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Inner</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">      c.say();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二种，在外部类中编写一个方法，可以返回 Inner 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Outer</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">      Outer.<span class="type">Inner</span> <span class="variable">i1</span> <span class="operator">=</span> o1.getInner();</span><br><span class="line">      i1.say();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;n1 = &quot;</span> + n1 + <span class="string">&quot;\nn2 = &quot;</span> + n2);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Inner <span class="title function_">getInner</span> <span class="params">()</span> &#123; <span class="comment">// 该对象返回一个Inner实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态内部类是定义在外部类的成员位置，并且有static修饰。</p>
<ol>
<li><p>可以直接访问外部类的所有&#x3D;&#x3D;静态&#x3D;&#x3D;成员，包括私有的，但是 <em><strong>不能直接访问非静态成员</strong></em>。</p>
</li>
<li><p>可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员。</p>
</li>
<li><p>作用域：同其他的成员一样，为整个类体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(name);</span><br><span class="line">         <span class="comment">// 不能直接访问外部类的非静态成员</span></span><br><span class="line">         <span class="comment">// System.out.println(n1);</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">StaticInner</span>().say();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>外部类访问静态内部类–&gt;创建对象再访问</p>
</li>
<li><p>外部其他类访问静态内部类–&gt;同成员内部类的两种方法（假如满足访问权限）<br>&#x3D;&#x3D;注意&#x3D;&#x3D;：静态内部类不需要外部类的实例来创建。静态内部类可以直接通过外部类的类名来创建实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.<span class="type">StaticInner</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInner();</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果外部类和静态内部类成员重名，默认遵守就近原则。假如只想访问外部类的那个成员，使用 【外部类名】.【成员变量名】（因为静态内部类能访问的成员变量只能是静态的）访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(name);</span><br><span class="line">         System.out.println(Outer.name);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="枚举与注解"><a href="#枚举与注解" class="headerlink" title="枚举与注解"></a>枚举与注解</h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>假如我们创建一个季节类（Season），由常识可知，季节（对象）有且仅有四个，并且我们不希望有人改变它们。那么用传统方法创建实例就无法满足。</p>
<p>此时利用枚举类解决。</p>
<h4 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h4><p>前面的情景其实说白了就是常量，只不过这次的常量变成了常量对象。</p>
<p>所以这种类特点如下：</p>
<ol>
<li>不需要提供setxx方法，因为枚举类对象通常为只读。可以提供getxx方法。</li>
<li>对枚举对象&#x2F;属性使用final + static共同修饰，实现底层优化。</li>
<li>枚举对象名与常量一样需要大写。</li>
<li>枚举对象根据需要也可以有多个属性。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">      System.out.println(Season.AUTUMN);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;万物复苏&quot;</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;酷热难耐&quot;</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;银装素裹&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.desc = desc;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> desc;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Season [name=&quot;</span> + name + <span class="string">&quot;, desc=&quot;</span> + desc + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Enum枚举类"><a href="#Enum枚举类" class="headerlink" title="Enum枚举类"></a>Enum枚举类</h4><h5 id="枚举类的基本语法"><a href="#枚举类的基本语法" class="headerlink" title="枚举类的基本语法"></a>枚举类的基本语法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">   SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;万物复苏&quot;</span>),</span><br><span class="line">   SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;酷热难耐&quot;</span>),</span><br><span class="line">   AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">   WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;银装素裹&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.desc = desc;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> desc;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Season [name=&quot;</span> + name + <span class="string">&quot;, desc=&quot;</span> + desc + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ol>
<li>成员属性和常量定义语句顺序不能变。</li>
<li>当我们使用enum关键字开发一个枚举类时，默认会继承Enum类，而且这个枚举类是final类。</li>
<li>如果使用的是无参构造器，可以只写名字然后啥也不加。</li>
</ol>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>在使用enum关键字时，会隐式继承Enum类，这样我们就可以使用Enum类相关的方法。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>valueOf</td>
<td>用于将传递的枚举类型的 Class 对象和枚举常量名称转换为对应的枚举常量。</td>
</tr>
<tr>
<td>toString</td>
<td>得到当前枚举常量的名称。可以重写来使得到的结果更易读</td>
</tr>
<tr>
<td>equals</td>
<td>在枚举类型中可以直接使用“ &#x3D;&#x3D; ”来比较两个枚举常量是否相等。Enum提供的这个equals方法也是直接使用“ &#x3D;&#x3D; ”来实现的。它的存在是为了在Set、List和Map中使用。注意，equals()是不可变的。</td>
</tr>
<tr>
<td>hashCode</td>
<td>Enum实现了hashCode()来和equals()保持一致。它也是不可变的。</td>
</tr>
<tr>
<td>getDeclaringClass</td>
<td>得到枚举常量所属枚举类型的class对象。可以用它来判断两个枚举常量是否属于同一个枚举类型。</td>
</tr>
<tr>
<td>name</td>
<td>得到当前枚举常量的名称。建议优先使用toString()。</td>
</tr>
<tr>
<td>ordinal</td>
<td>得到当前枚举常量的次序（编号，从零开始）。</td>
</tr>
<tr>
<td>compareTo</td>
<td>枚举类型实现了Comparable接口，这样就可以比较两个枚举常量的大小（按照声明的顺序排列），返回的是顺序值的差值。</td>
</tr>
<tr>
<td>clone</td>
<td>枚举类型不能被Clone子类实现克隆方法，Enum实现了一个仅抛出CloneNotSupportedException异常的不便Clone()</td>
</tr>
</tbody></table>
<h5 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h5><ol>
<li><p>使用enum关键字后，就不能再继承其他类了，因为enum会隐式继承Enum类，而Java是单继承机制。</p>
</li>
<li><p>枚举类与普通类一样，可以实现接口，如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">      B.CIAO.hi();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   CIAO; <span class="comment">// 常量就是枚举类的实例，因此枚举类的方法要用常量来调用。</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hi!!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解（Annotation）又被称为元数据（Metadata），用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。</p>
<p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。</p>
<p>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE中的注解占据了更为重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</p>
<p>使用Annotation时要加上@符号，并把该Annotation当成一个修饰符使用。用于修饰它支持的程序元素。</p>
<h4 id="Override注解"><a href="#Override注解" class="headerlink" title="Override注解"></a>Override注解</h4><p>用于限定某个方法，是重写父类方法。该注解只能用于方法。</p>
<p>在继承、抽象、接口用过好多次，没啥好讲的。事实上，不加Override程序照样可以构成正常的重写。它的作用就是让编译器去检查该方法是否真的重写了父类的方法，没有就报错。</p>
<h4 id="Despressted注解"><a href="#Despressted注解" class="headerlink" title="Despressted注解"></a>Despressted注解</h4><p>用于表示某个程序元素（类，方法等）已经过时。</p>
<p>用于新旧版本的升级与过渡。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">tempA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(); <span class="comment">// The value of the local variable tempA is not used</span></span><br><span class="line">        tempA.hi();</span><br><span class="line">        System.out.println(tempA.n1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.@Deprecated 修饰某个元素，表示该元素已过时</span></span><br><span class="line"><span class="comment"> * 2. 过时意思是不推荐使用，不是不能使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hi!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SuppressWarnings注解"><a href="#SuppressWarnings注解" class="headerlink" title="SuppressWarnings注解"></a>SuppressWarnings注解</h4><p>用于抑制编译器警告。<br>作用范围与位置有关，在什么之前范围就是什么。（例如你将它放在一个方法前，作用范围就是一个方法。类之前，就是一个类的范围）</p>
<p>@SuppressWarnings 注解可以抑制多种类型的编译器警告。可以将这些警告传入（可以是数组），以下是一些常见的警告类型：</p>
<ol>
<li>unchecked：抑制未经检查的操作警告，例如使用原始类型的集合。</li>
<li>deprecation：抑制使用已过时的类或方法的警告。</li>
<li>serial：抑制缺少 serialVersionUID 字段的警告。</li>
<li>rawtypes：抑制使用原始类型的警告。</li>
<li>unused：抑制未使用的变量或方法的警告。</li>
<li>fallthrough：抑制 switch 语句中 case 分支没有 break 的警告。</li>
<li>cast：抑制不安全的类型转换的警告。</li>
<li>divzero：抑制除以零的警告。</li>
<li>finally：抑制 finally 块中没有返回的警告。</li>
<li>all：抑制所有警告。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       list.add(<span class="string">&quot;jack&quot;</span>) ;</span><br><span class="line">       list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">       System.out.println(list.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四种元注解（-）"><a href="#四种元注解（-）" class="headerlink" title="四种元注解（*）"></a>四种元注解（*）</h4><p>元注解即为修饰注解的注解。</p>
<p>元注解的种类：</p>
<ol>
<li>Retention &#x2F;&#x2F; 指定注解 <em><strong>作用</strong></em> 范围，三种（SOURSE，CLASS，RUNTIME）</li>
<li>Target &#x2F;&#x2F; 指定注解的 <em><strong>使用</strong></em> 范围</li>
<li>Documented &#x2F;&#x2F; 指定直接是否会在javadoc里体现</li>
<li>Inherited &#x2F;&#x2F; 子类会继承父类注解</li>
</ol>
<p>一般在jdk里见得多，例如常用注解的定义里。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>基本概念：</p>
<p>在Java语言中，将程序执行中发生的不正常情况称为“异常”。（语法错误和逻辑错误不是异常）</p>
<p>执行过程中所发生的异常事件可分为两类：</p>
<ol>
<li>Error（错误）：Java虚拟机无法解决的严重问题，如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError【栈溢出】和OOM（out of memory），Error是严重错误，程序会崩溃。</li>
<li>Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，Exception分为两大类：运行时异常和编译时异常。</li>
</ol>
<p>Java的运行顺序如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Java源程序--javac.exe--&gt;字节码文件--java.exe--&gt;在内存中加载、运行类</span><br></pre></td></tr></table></figure>

<h3 id="异常体系图"><a href="#异常体系图" class="headerlink" title="异常体系图"></a>异常体系图</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">java.lang.Throwable</span><br><span class="line">    ├── java.lang.Error</span><br><span class="line">    │   ├── java.lang.OutOfMemoryError</span><br><span class="line">    │   ├── java.lang.StackOverflowError</span><br><span class="line">    │   └── java.lang.VirtualMachineError</span><br><span class="line">    └── java.lang.Exception</span><br><span class="line">        ├── java.io.IOException</span><br><span class="line">        ├── java.sql.SQLException</span><br><span class="line">        ├── java.lang.ClassNotFoundException</span><br><span class="line">        ├── java.lang.RuntimeException</span><br><span class="line">            ├── java.lang.NullPointerException</span><br><span class="line">            ├── java.lang.ArrayIndexOutOfBoundsException</span><br><span class="line">            ├── java.lang.ArithmeticException</span><br><span class="line">            ├── java.lang.IllegalArgumentException</span><br><span class="line">            └── java.lang.NumberFormatException</span><br></pre></td></tr></table></figure>

<h3 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h3><p>Exception 包含了编译时异常和运行时异常两类。编译时异常（Checked Exception）是在编译阶段被检查的异常，必须要进行处理；而运行时异常（Unchecked Exception）是在运行时才可能发生的异常，不强制要求处理。</p>
<h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><ol>
<li><p>NullPointerException 空指针异常<br>当应用程序试图在需要对象的地方使用null时，抛出该异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(name.length());</span><br><span class="line"><span class="comment">// Null pointer access: The variable name can only be null at this locationJava(536871363)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>AirthmeticException 数学运算异常</p>
</li>
<li><p>ArryIndexOutOfBoundException 数组下标越界异常<br>老朋友，不写了。</p>
</li>
<li><p>ClassCastException 类型转换异常<br>当试图将对象强制转换为不是实例的子类时，抛出该异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">A</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">// 向上转型</span></span><br><span class="line">      <span class="type">B</span> <span class="variable">b2</span> <span class="operator">=</span> (B)b; <span class="comment">// 向下转型，因为b本来就是B类型的</span></span><br><span class="line">      <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> (C)b; <span class="comment">// 不行，因为B和C没关系</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="comment">// Exception in thread &quot;main&quot; java.lang.ClassCastException: class B cannot be cast to class C (B and C are in unnamed module of loader &#x27;app&#x27;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>NumberFormatException 数字格式不正确异常<br>当程序试图将字符串转换成一种数值类型，但是该字符串不能转换为合适的格式时，抛出该异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;Tom&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h4><ol>
<li>SQLException &#x2F;&#x2F; 操作数据库时，查询表可能发生异常</li>
<li>IOException &#x2F;&#x2F; 操作文件时</li>
<li>FileNotFoundException &#x2F;&#x2F; 当操作一个不存在的文件时</li>
<li>ClassNotFoundException &#x2F;&#x2F; 加载类，而该类不存在时</li>
<li>EOFException &#x2F;&#x2F; 操作文件，到文件末尾</li>
<li>IllegalArguementException &#x2F;&#x2F; 参数异常</li>
</ol>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="异常处理概念"><a href="#异常处理概念" class="headerlink" title="异常处理概念"></a>异常处理概念</h4><p>基本介绍：异常处理就是当异常发生时，对异常处理的方式。</p>
<h4 id="异常处理分类"><a href="#异常处理分类" class="headerlink" title="异常处理分类"></a>异常处理分类</h4><ol>
<li><p><strong>try-catch</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 可能有异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   <span class="comment">// 捕获到异常</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *1. 一旦异常发生，直接跳到catch。（下面的就不管了）</span></span><br><span class="line"><span class="comment">   *2. 如果异常没有发生，则顺序执行try的代码块，不会进入catch</span></span><br><span class="line"><span class="comment">   *3. 系统将异常封装成Exception对象e，传递给catch</span></span><br><span class="line"><span class="comment">   *4. 这个Exception对象可以替换为特定的Exception对象，如上面介绍过的编译异常和运行异常中的，用于捕获特定异常。也就是说，我们甚至可以写多个catch来捕获不同的Exception对象来分别进行不同的业务处理。（要求父类异常在前，子类异常在后。如果发生异常只会匹配一个catch）</span></span><br><span class="line"><span class="comment">   *5. 得到异常对象后，我们自己处理</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="comment">// 不管try代码块是否有异常，finally始终要执行</span></span><br><span class="line">   <span class="comment">// 可以放文件/系统/数据库…等的关闭（释放资源）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用try-finally配合使用，这种用法相当于没有捕获异常，因此程序会直接崩溃。其应用场景在于，执行一段代码，不管是否发生异常，都 <em><strong>必须</strong></em> 实现某个业务逻辑。</p>
<p>一个小练习：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要求写一个程序，在不输入数字时一直重复提醒用户直到输入正确为止。</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">      <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">inputnum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               input = scan.nextLine();</span><br><span class="line">               inputnum = Integer.parseInt(input);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;Error!!&quot;</span>);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      scan.close();</span><br><span class="line">      System.out.println(inputnum);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>throws</strong></p>
<ul>
<li>如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理，则此方法应显式声明抛出异常表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</li>
<li>在方法声明中用throws语句以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。也可以是异常列表。</li>
<li>子类在重写父类的方法时，对抛出异常的规定：子类重写的方法所抛出的异常要么与父类抛出的一致，要么是父类抛出异常类型的子类型。</li>
<li>在throws执行过程中，如果有方法try-catch，就相当于处理异常，就不会再向上层throws了。</li>
<li>调用抛出编译异常的方法时，必须处理该异常，否则编译器会报错。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">test</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">test</span>();</span><br><span class="line">      temp.f();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> NumberFormatException &#123;</span><br><span class="line">      <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">      <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">inputnum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      input = scan.nextLine();</span><br><span class="line">      inputnum = Integer.parseInt(input);</span><br><span class="line">      scan.close(); </span><br><span class="line">      System.out.println(inputnum);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>throw</strong></p>
<ul>
<li>throw 关键字用于显式地抛出一个异常。</li>
<li>通常用于方法体内，用来抛出一个具体的 <em><strong>异常实例</strong></em>。</li>
<li>语法格式：throw new ExceptionType(“Error Message”);</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         validateAge(<span class="number">15</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         System.out.println(e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">validateAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;年龄必须大于18岁&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>当程序中出现了某些错误，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息。</p>
<p>步骤：</p>
<ol>
<li>定义类：自定义异常类名，继承Exception或者或RuntimeException</li>
<li>如果继承Exception，属于编译异常</li>
<li>如果继承RunTimeException，属于运行异常（一般继承这个）</li>
</ol>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">180</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(age &gt;= <span class="number">18</span> &amp;&amp; age &lt;= <span class="number">120</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;年龄不在范围内！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;范围正确&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">      <span class="comment">// 通过构造器设置返回信息</span></span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="throw和throws的对比"><a href="#throw和throws的对比" class="headerlink" title="throw和throws的对比"></a>throw和throws的对比</h3><table>
<thead>
<tr>
<th></th>
<th>意义</th>
<th>位置</th>
<th>后面跟的东西</th>
</tr>
</thead>
<tbody><tr>
<td>throws</td>
<td>异常处理的一种方式</td>
<td>方法声明处</td>
<td>异常类型</td>
</tr>
<tr>
<td>throw</td>
<td>手动生成&#x3D;&#x3D;异常对象&#x3D;&#x3D;的关键字</td>
<td>方法体中</td>
<td>异常对象</td>
</tr>
</tbody></table>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><p>你懂的，就是一些常见的，常用的类。</p>
<h3 id="包装类（Wrapper）"><a href="#包装类（Wrapper）" class="headerlink" title="包装类（Wrapper）"></a>包装类（Wrapper）</h3><h4 id="包装类的基本概念"><a href="#包装类的基本概念" class="headerlink" title="包装类的基本概念"></a>包装类的基本概念</h4><p>概念：针对八种基本数据类型对应的引用类型。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<p>Boolean 和 Character 直接继承自 java.lang.Object。<br>其他六个包装类继承自 java.lang.Number。</p>
<p>jdk5以后的装箱（基本类型-&gt;包装类型）与拆箱都是自动的，底层调用的是valueOf方法。</p>
<h4 id="包装类的转换"><a href="#包装类的转换" class="headerlink" title="包装类的转换"></a>包装类的转换</h4><ul>
<li>包装类-&gt;String(前提代码语句：<code>Integer i = 100;</code>，自动装箱)<ol>
<li><code>String str = i + &quot;&quot;;</code></li>
<li><code>String str = i.toString();</code></li>
<li><code>String str = String.valuOf()</code></li>
</ol>
</li>
<li>String-&gt;包装类(前提代码语句：<code>String str = &quot;100&quot;;</code>)<ol>
<li><code>Integer i = Integer.paseInt(str);</code>（自动装箱）</li>
<li><code>Integer i = new Integer(str);</code>（构造器）</li>
</ol>
</li>
</ul>
<h4 id="包装类的常用静态方法与属性"><a href="#包装类的常用静态方法与属性" class="headerlink" title="包装类的常用静态方法与属性"></a>包装类的常用静态方法与属性</h4><ul>
<li>Integer<ol>
<li>Integer.MIN_VALUE &#x2F;&#x2F; 返回最小值</li>
<li>Integer.MAX_VALUE &#x2F;&#x2F; 返回最大值</li>
</ol>
</li>
<li>Character<ol>
<li><p>isDigit() &#x2F;&#x2F; 判断是不是数字<br>一般用来判断字符串是不是数字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNumeric</span><span class="params">(String str)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!Character.isDigit(c)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>isLetter() &#x2F;&#x2F; 判断是不是字母</p>
</li>
<li><p>isUpperCase() &#x2F;&#x2F; 判断是不是大写</p>
</li>
<li><p>isLowerCase() &#x2F;&#x2F; 判断是不是小写</p>
</li>
<li><p>isWhitespace() &#x2F;&#x2F; 判断是不是空格</p>
</li>
<li><p>toUpperCase() &#x2F;&#x2F; 转成大写</p>
</li>
<li><p>toLowerCase() &#x2F;&#x2F; 转成小写</p>
</li>
</ol>
</li>
</ul>
<h4 id="包装类注意事项"><a href="#包装类注意事项" class="headerlink" title="包装类注意事项"></a>包装类注意事项</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>); <span class="comment">// 这种方式实际上已经被逐步弃用了，建议用valueOf()</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(i == j);</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(i1 == j1);</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(i2 == j2);</span><br></pre></td></tr></table></figure>

<p>当使用自动装箱（autoboxing）将基本类型 int 转换为 Integer 对象时，Java 会对值在 -128 到 127 范围内的整数进行缓存。因此，如果 i 和 j 的值在这个范围内，它们会引用同一个缓存对象。</p>
<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><h4 id="String类的基本概念"><a href="#String类的基本概念" class="headerlink" title="String类的基本概念"></a>String类的基本概念</h4><ol>
<li>String对象用于保存字符串，也就是一组字符序列。</li>
<li>字符串常量对象是用 <em><strong>双引号</strong></em> 括起的字符序列。例如：”你好”，”12.97”，”boy”等。</li>
<li>字符串的字符使用Unicode字符编码，一个字符（不区分字母和汉字）占两个字节。</li>
<li>String类是final类型，不能被其他类继承。</li>
<li>String类实现了接口Serializable（可以串行化，即可以在网络传输），接口Comparable（String对象可以比较大小）</li>
<li>String类是final的。</li>
<li>String有属性private final char value[]，用于存放字符串内容。（value是final类型，不可以修改【地址】，而不是值）</li>
</ol>
<h4 id="String类的常用构造器与对象创建"><a href="#String类的常用构造器与对象创建" class="headerlink" title="String类的常用构造器与对象创建"></a>String类的常用构造器与对象创建</h4><ol>
<li>常用构造器<ul>
<li><code>String s1 = new String();</code></li>
<li><code>String s2 = new String(String oringinal);</code></li>
<li><code>String s2 = new String(char[] a);</code></li>
<li><code>String s2 = new String(char[] a, int startindex, int count);</code></li>
<li><code>String s2 = new String(byte[] b);</code></li>
</ul>
</li>
<li>对象创建方式<ul>
<li>直接赋值：<code>String s = &quot;faiz&quot;;</code></li>
<li>调用构造器：<code>String s = new String(&quot;faiz&quot;);</code></li>
<li>在内存里和包装类不一样，如果用第一种方法，它会先找常量池里有没有值一样的，如果有就直接指向，如果没有自己再new一个新的；如果用第二种，它是先找常量池里有没有值一样的，然后在堆中指向这个常量，但是这个时候地址肯定不一样。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;faiz&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;faiz&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(a == b.intern()); <span class="comment">// intern方法返回的是这个值在常量池中的地址。</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串特性"><a href="#字符串特性" class="headerlink" title="字符串特性"></a>字符串特性</h4><ol>
<li>String是一个final类，代表不可变的字符序列（常量 ）。</li>
<li>字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的。<ul>
<li><code>String s1 = &quot;hello&quot;;</code><br> <code>s1 = &quot;hi&quot;;</code><br> 以上语句实际上创建了两个字符串对象，s1从”hello”又指向了”hi”。</li>
<li><code>String a = &quot;hello&quot; + &quot;abc&quot;;</code><br> 此时编译器并不会创建3个对象，而是在底层优化判断创建的常量值是否有引用指向，等价为<code>String a = &quot;helloabc&quot;;</code>所以只创建了1个对象。</li>
<li><code>String a = &quot;hello&quot;;</code><br> <code>String b = &quot;abc&quot;;</code><br> <code>String c = a + b;</code><ol>
<li>创建了一个<code>StringBuilder sb  = StringBuilder();</code></li>
<li>执行 <code>sb.append(&quot;hello&quot;);</code></li>
<li>执行<code>sb.append(&quot;abc&quot;);</code></li>
<li>执行<code>String c = sb.toString();</code><br> 最后其实是c指向了对象（String）value[] -&gt; 池中”helloabc”</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h4><ul>
<li><p>equals() &#x2F;&#x2F; <em>区分</em>大小写，判断内容是否相等</p>
</li>
<li><p>equalsIgnoreCase() &#x2F;&#x2F; <em>忽略</em>大小写，判断内容是否相等</p>
</li>
<li><p>length() &#x2F;&#x2F; 返回字符串长度</p>
</li>
<li><p>indexOf(String str) &#x2F;&#x2F; 返回该字符（串）在字符串中第一次出现的位置（找不到返回-1）</p>
</li>
<li><p>lastIndexOf(String str) &#x2F;&#x2F; 返回该字符（串）在字符串中最后一次出现的位置（找不到返回-1）</p>
</li>
<li><p>substring(int begin, int end) &#x2F;&#x2F; 截取指定范围（前闭后开）字符串</p>
</li>
<li><p>trim() &#x2F;&#x2F; 去除前后空格</p>
</li>
<li><p>charAt() &#x2F;&#x2F; 返回索引处字符，注意！String不可以用 <em><strong>str[index]</strong></em> 这种方式</p>
</li>
<li><p>toUpperCase() &#x2F;&#x2F; 转为大写</p>
</li>
<li><p>toLowerCase() &#x2F;&#x2F; 转为小写</p>
</li>
<li><p>concat(String str) &#x2F;&#x2F; 拼接原有字符串后面</p>
</li>
<li><p>replace(String s1, String s2) &#x2F;&#x2F; 将字符串里所有的s1替换为s2（但是原字符串不会变！！）</p>
</li>
<li><p>split() &#x2F;&#x2F; 分割字符串，对于分割字符，我们需要转义，如：“|”、\”。注意返回的是字符串数组！！！</p>
</li>
<li><p>compareTo() &#x2F;&#x2F; 比较两个字符串的大小，长度不一样字符一样返回长度差；长度一样字符不一样、长度不一样字符不一样返回字符差（根据字符串中第一个不同字符的 Unicode 值差计算）</p>
</li>
<li><p><strong>toCharArray() &#x2F;&#x2F;转换为字符数组（String–&gt;char[]）</strong><br> <strong>char[]–&gt;String可以直接把字符数组传到new String()中。</strong></p>
</li>
<li><p>format() &#x2F;&#x2F; 格式化字符串（常用于精度控制）</p>
</li>
<li><p>toString()<br> 在 Java 中，如果一个类没有重写 toString 方法，那么该类的默认字符串表示形式是由 Object 类的 toString 方法提供的。默认情况下，toString 方法返回一个字符串，格式如下：</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">类名@对象的哈希码的十六进制表示</span><br></pre></td></tr></table></figure>

<p> 例如，如果你有一个 Book 对象，默认的 toString 方法可能会返回类似于 Book@1a2b3c4d 的字符串。</p>
</li>
</ul>
<h3 id="StringBuffer类和StringBuilder类"><a href="#StringBuffer类和StringBuilder类" class="headerlink" title="StringBuffer类和StringBuilder类"></a>StringBuffer类和StringBuilder类</h3><h4 id="StringButter类"><a href="#StringButter类" class="headerlink" title="StringButter类"></a>StringButter类</h4><h5 id="StringBuffer类简介"><a href="#StringBuffer类简介" class="headerlink" title="StringBuffer类简介"></a>StringBuffer类简介</h5><ul>
<li>代表可变的字符序列，可以对字符串内容进行增删。</li>
<li>很多方法相同，但StringBuffer是可变长度的。</li>
<li>StringBuffer是一个容器。</li>
<li>StringBuffer的直接父类是AbstractStringBuffer</li>
<li>~实现了Serializable，即可以串行化</li>
<li>在父类中，AbstractStringBuilder有属性char[] value（这个属性不是final！！放在堆里）该value数组存放字符串内容，引出存放在堆中的。</li>
<li>~是final的，不能被继承</li>
</ul>
<h5 id="StringBuffer类与String类的比较"><a href="#StringBuffer类与String类的比较" class="headerlink" title="StringBuffer类与String类的比较"></a>StringBuffer类与String类的比较</h5><ol>
<li>String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低</li>
<li>StringBuffer类保存的是字符串变量，里面的值可以更改，StringBuffer每次更新会实际上可以更新的内容，不用每次更新地址，效率极高。</li>
</ol>
<h5 id="StringBuffer实例化"><a href="#StringBuffer实例化" class="headerlink" title="StringBuffer实例化"></a>StringBuffer实例化</h5><ol>
<li><code>StringBuffer testStringBuffer = new  StringBuffer();</code><br>创建一个大小为16的char[],用于存放字符内容</li>
<li><code>StringBuffer testStringBuffer = new StringBuffer(100);</code><br>通过构造器指定char[]的大小（实际上大小为你规定的+16）</li>
</ol>
<p>互相转换：</p>
<ul>
<li>String-&gt;StringBuffer<ol>
<li>使用构造器，参数不能为空（null），会报空指针异常。因为底层需要调用str（传入的那个字符串）.length<br><code>String a = &quot;hello&quot;;</code><br><code>StringBuffer testStringBuffer = new StringBuffer(a);</code><br>这样并不会改变a本身。</li>
<li>使用append方法，传空（null）也没关系，会在底层转化为字符数组[‘n’, ‘u’, ‘l’, ‘l’]<br><code>String a = &quot;hello&quot;;</code><br><code>StringBuffer testStringBuffer = new StringBuffer();</code><br><code>testStringBuffer.append(a);</code></li>
</ol>
</li>
<li>StringBuffer-&gt;String<ol>
<li>StringBuffer的toString方法<br><code>StringBuffer testStringBuffer = new StringBuffer();</code><br><code>String s = testStringBuffer.toString();</code></li>
<li>使用构造器<br><code>StringBuffer testStringBuffer = new StringBuffer();</code><br><code>String s = new String(testStringBuffer);</code></li>
</ol>
</li>
</ul>
<h5 id="StringBuffer类的常用方法"><a href="#StringBuffer类的常用方法" class="headerlink" title="StringBuffer类的常用方法"></a>StringBuffer类的常用方法</h5><ol>
<li>append() &#x2F;&#x2F; 追加</li>
<li>delete(int start, int end) &#x2F;&#x2F; 删除，前闭后开</li>
<li>replace(int start, int end, String str) &#x2F;&#x2F; 替换，前闭后开</li>
<li>indexOf(String str) &#x2F;&#x2F; 查找字符串str第一次出现的索引，找不到返回-1</li>
<li>lastIndexOf(String str) &#x2F;&#x2F; 查找字符串str最后一次一次出现的索引，找不到返回-1</li>
<li>insert(int index, String str) &#x2F;&#x2F; 在index处插入str，后面的内容自动后移</li>
<li>length() &#x2F;&#x2F; 返回字符串长度</li>
</ol>
<h4 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h4><h5 id="StringBuilder类简介"><a href="#StringBuilder类简介" class="headerlink" title="StringBuilder类简介"></a>StringBuilder类简介</h5><ul>
<li>一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步（不是线程安全的）。该类被设计用作StringBuffer的一个简易替换，用 <em><strong>在字符串缓冲区被单个线程使用的时候</strong></em> 。如果可能建议优先采用该类，因为在大多数实现中，它比StringBuffer要快。</li>
<li>在StringBuilder上的主要操作是append和insert方法，可重载这些方法以接受任意类型的数据。</li>
<li>StringBuilder是final的。</li>
<li>继承了AbstractStringBuilder，含属性char[] value，字符串内容存在value里。</li>
<li>实现了Serializable接口，是可串行化的（即可以网络传输，可保存到文件）</li>
</ul>
<h5 id="StringBuilder常用方法"><a href="#StringBuilder常用方法" class="headerlink" title="StringBuilder常用方法"></a>StringBuilder常用方法</h5><p>StringBuilderr和StringBuffe均代表可变的字符序列，方法是一样的，所以使用和StringBuffer一样。</p>
<h5 id="String、StringBuilder、StringBuffer的比较"><a href="#String、StringBuilder、StringBuffer的比较" class="headerlink" title="String、StringBuilder、StringBuffer的比较"></a>String、StringBuilder、StringBuffer的比较</h5><p>从效率看：StringBuilder &gt; StringBuffer &gt; String</p>
<p>使用原则（结论）：</p>
<ol>
<li>如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder</li>
<li>如果字符串存在大量的修改操作，并存在单线程的情况，使用StringBuilder</li>
<li>如果字符串存在大量的修改操作，并存在多线程的情况，使用StringBuffer</li>
<li>如果字符串很少被修改，并且被多个对象引用，使用String（例如配置信息等）</li>
</ol>
<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>常用方法：</p>
<ul>
<li><p>abs() &#x2F;&#x2F; 求绝对值</p>
</li>
<li><p>pow() &#x2F;&#x2F; 求幂</p>
</li>
<li><p>ceil() &#x2F;&#x2F; 向上取整</p>
</li>
<li><p>floor() &#x2F;&#x2F; 向下取整</p>
</li>
<li><p>round() &#x2F;&#x2F; 四舍五入</p>
</li>
<li><p>sqrt() &#x2F;&#x2F; 求开方</p>
</li>
<li><p>random() &#x2F;&#x2F; 返回0<del>1之间的随机数，没有参数！！<br> 返回特定范围的随机数（以1</del>10为例）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">randomInt</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * (max - min + <span class="number">1</span>)) + min;</span><br><span class="line">System.out.println(randomInt);</span><br></pre></td></tr></table></figure>
</li>
<li><p>max(int n1, int n2) &#x2F;&#x2F; 求两者的最大值</p>
</li>
<li><p>min(int n1, int n2) &#x2F;&#x2F; 求两者的最小值</p>
</li>
</ul>
<h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p>Arrays类在util包中，该类包含了一系列静态方法，用于管理或操作数组。</p>
<ul>
<li><p>toString() &#x2F;&#x2F; 返回数组的字符串形式</p>
</li>
<li><p>sort() &#x2F;&#x2F; 顺序排序<br> 定制排序</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Integer[] test = &#123;<span class="number">5</span>, <span class="number">17</span>, <span class="number">15</span>, <span class="number">65</span>, <span class="number">8</span>, <span class="number">66</span>&#125;; <span class="comment">// Comparator 只能用于对象数组，而不是基本类型数组。要对基本类型数组进行排序，你需要将其转换为包装类型数组（如 Integer[]）。</span></span><br><span class="line">      Arrays.sort(test, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123; <span class="comment">// 可以看到实际上是匿名内部类，尖括号里是泛型，后面再讲。</span></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> o2 - o1; <span class="comment">// 这里要注意返回类型，如果不是int就写一个判断（if）来返回（1，-1，0）</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      System.out.println(Arrays.toString(test));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Comparator是 Java 中的一个接口，用于定义对象的比较规则。它通常用于排序操作，例如通过 Arrays.sort 或 Collections.sort 方法对集合进行排序。Comparator 接口包含一个方法 compare(T o1, T o2)，该方法用于比较两个对象 o1 和 o2。</p>
<p> compare 方法的实现决定了排序的顺序（底层实际上是二叉排序，所以要差值）：</p>
<ul>
<li>如果返回负值，表示 o1 小于 o2，<strong>从小到大排</strong>。</li>
<li>如果返回零，表示 o1 等于 o2。</li>
<li>如果返回正值，表示 o1 大于 o2，<strong>从大到小排</strong>。</li>
</ul>
<p> 还可以自己仿照sort方法写一个其他的排序</p>
</li>
<li><p>binarySearch(Object[] array, Object element) &#x2F;&#x2F; 二叉查找某值，返回该值的索引（要求数组<strong>必须</strong>有序），如果找不到就返回（-（数组长度+1））</p>
</li>
<li><p>copyOf(Object[] array, int length) &#x2F;&#x2F; 从array数组中拷贝length个元素到新数组后面，如果不写length参数，就是拷贝array.length个元素。假如length &lt; 0 ，会抛出异常。</p>
</li>
<li><p>fill(Object[] array, Object element) &#x2F;&#x2F; 将非空数组中的所有元素都填充为element。（其实空的也没关系啦，只是这条语句过后数组还是空的）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] num = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Arrays.fill(num, <span class="number">99</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>equals() &#x2F;&#x2F; 比较两个数组元素是否一致（长度也算），返回boolean类型。（在Java里，boolean也是可以直接输出的）</p>
</li>
<li><p><em><strong>aList()</strong></em> &#x2F;&#x2F; 将数组转成集合List集合<br> 一般这样用：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">newCars</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(Arrays.asList(</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;奥迪&quot;</span>, <span class="number">300000</span>),</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;奔驰&quot;</span>, <span class="number">350000</span>)</span><br><span class="line">));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>系统类</p>
<h4 id="System类的常见方法"><a href="#System类的常见方法" class="headerlink" title="System类的常见方法"></a>System类的常见方法</h4><ul>
<li>exit() &#x2F;&#x2F; 退出当前程序</li>
<li>arraycopy(Object[] src, int srcPos, Object[] dest, int destPos, int length) &#x2F;&#x2F; 将src数组从srcPos位置开始到srcPos + length - 1的子序列复制到dest数组从destPos位置到destPos + length - 1（在底层调用，一般使用Arrays.copyOf()）</li>
<li>currentTimeMillens() &#x2F;&#x2F; 返回当前时间距离1970-01-01的毫秒数</li>
<li>gc() &#x2F;&#x2F; 运行垃圾回收机制</li>
</ul>
<h3 id="BigInteger类和BigDecimal类"><a href="#BigInteger类和BigDecimal类" class="headerlink" title="BigInteger类和BigDecimal类"></a>BigInteger类和BigDecimal类</h3><p>这两个类下属math包。</p>
<p>应用场景：</p>
<ol>
<li><p>BigInteger适合保存比较大的整型。<br>常见方法：</p>
<ul>
<li>add(BigInteger b1) &#x2F;&#x2F; 加</li>
<li>subtract(BigInteger b1) &#x2F;&#x2F; 减</li>
<li>multiply(BigInteger b1) &#x2F;&#x2F; 乘</li>
<li>divide(BigInteger b1) &#x2F;&#x2F; 除<br>须知这些方法返回类型还是BigInteger。</li>
</ul>
</li>
<li><p>BigDecimal适合保存精度更高的浮点型。<br>加减乘除这些方法和BigInteger一样。<br>注意：使用divide()时可能会抛出异常，因为结果可能是无限循环小数。<br>解决方式：指定精度即可。增加参数–BigDecimal.ROUND_CEILING，在出现无限循环小数时就会保留与被除数相同的精度。</p>
</li>
</ol>
<h3 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3><p>分为三代。</p>
<h4 id="第一代日期类–Date类"><a href="#第一代日期类–Date类" class="headerlink" title="第一代日期类–Date类"></a>第一代日期类–Date类</h4><p>下属util包，可以精确到毫秒，代表特定的瞬间。</p>
<h5 id="Date的特定格式化解析输出（Date-String）"><a href="#Date的特定格式化解析输出（Date-String）" class="headerlink" title="Date的特定格式化解析输出（Date -&gt; String）"></a>Date的特定格式化解析输出（Date -&gt; String）</h5><p>首先，Date是可以直接输出的，但是输出的格式是国外的默认形式，如果我们想要改变格式，就需要用到一个下属类：SimpleDateFormat。</p>
<p>SimpleDateFormat类 <em><strong>在text包内</strong></em>，用于格式化和解析具体日期。该类允许进行格式化（日期-&gt;文本），解析（文本-&gt;日期）和规范化。</p>
<p>用此类下属的format方法解析Date类之后返回的类型实际上是String。这样一来就可以输出成我们想要的格式了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">tesDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">testformat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> testformat.format(tesDate);</span><br><span class="line">System.out.println(format);</span><br></pre></td></tr></table></figure>

<p>注意格式书写的时候那些ym等等字母不是随便写的！大小写都有不同含义！！自己看API吧。</p>
<p>（*）还可以指定毫秒数输出时间，返回自1970-01-01加上你输入的毫秒数时间（这个参数是long类型的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">tesDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">9999999</span>);</span><br><span class="line">System.out.println(tesDate);</span><br></pre></td></tr></table></figure>

<h5 id="String-Date"><a href="#String-Date" class="headerlink" title="String -&gt; Date"></a>String -&gt; Date</h5><p>用的是SimpleDateFormat的方法–parse。</p>
<p>可以把一个格式化的String转成对应的Date。但是得到的Date在输出时仍然是按照默认（国外）形式，想转换还是用SimpleDateFormat。否则会抛出转换异常。</p>
<p>在转换时，需要保证String格式与SimpleDateFormat的格式一样，否则会抛出转换异常。<em><strong>但是无论格式是否一样，都需要在这里异常处理</strong></em>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;1996年01月01日 10:20:30 星期一&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">Date</span> <span class="variable">pareds</span> <span class="operator">=</span> rule.parse(test);</span><br><span class="line">   System.out.println(rule.format(pareds));</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二代日期类–Calendar类"><a href="#第二代日期类–Calendar类" class="headerlink" title="第二代日期类–Calendar类"></a>第二代日期类–Calendar类</h4><p>Calendar类来自util包。它是一个 <strong>抽象类</strong>。所以在实例化时只能用getinstance()【<a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82">getinstance()是啥？</a>】</p>
<p>Calendar的所有信息全都储存在字段里，所以我们要想输出特定的年月日，只需提取特定字段输出即可。（当然直接输出Calendar也没关系，只是会把Calendar的所有信息以及所有字段全部直接输出，数量非常多而且没有什么格式，不美观）</p>
<p>注意！Calendar 类中的字段（如 YEAR、MONTH 等）是静态常量（static final）！它们只是用来表示特定的日历字段的标识符。这些字段本身并不包含具体的日期或时间值。</p>
<p>要获取具体的日期或时间值，需要一个 Calendar 对象，因为这些值是与特定的 Calendar 实例相关联的。然后再用get()方法就可以调用这些静态字段啦。</p>
<p>eg.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;年：&quot;</span> + c.get(Calendar.YEAR));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;月：&quot;</span> + (c.get(Calendar.MONTH) + <span class="number">1</span>)); <span class="comment">// 月份默认从0开始算，所以要加一</span></span><br><span class="line"><span class="comment">// 来复习一下“+”怎么用：String + 任何基本类型最后都会变成String。所以需要括号括住先算加法再默认转成String</span></span><br><span class="line">System.out.println(<span class="string">&quot;日：&quot;</span> + c.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(<span class="string">&quot;小时：&quot;</span> + c.get(Calendar.HOUR));</span><br><span class="line"><span class="comment">// HOUR字段是12小时制，想要24小时制可以输出字段HOUR_OF_DAY</span></span><br><span class="line">System.out.println(<span class="string">&quot;分钟：&quot;</span> + c.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(<span class="string">&quot;秒：&quot;</span> + c.get(Calendar.SECOND));</span><br><span class="line"></span><br><span class="line">System.out.println(c);</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// java.util.GregorianCalendar[time=1731814184272,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=&quot;Asia/Shanghai&quot;,offset=28800000,dstSavings=0,useDaylight=false,transitions=31,lastRule=null],firstDayOfWeek=2,minimalDaysInFirstWeek=1,ERA=1,YEAR=2024,MONTH=10,WEEK_OF_YEAR=46,WEEK_OF_MONTH=3,DAY_OF_MONTH=17,DAY_OF_YEAR=322,DAY_OF_WEEK=1,DAY_OF_WEEK_IN_MONTH=3,AM_PM=0,HOUR=11,HOUR_OF_DAY=11,MINUTE=29,SECOND=44,MILLISECOND=272,ZONE_OFFSET=28800000,DST_OFFSET=0]</span></span><br><span class="line"></span><br><span class="line">System.out.println(c.get(Calendar.YEAR) + <span class="string">&quot;年&quot;</span> + (c.get(Calendar.MONTH) + <span class="number">1</span>) + <span class="string">&quot;月&quot;</span> + c.get(Calendar.DAY_OF_MONTH) + <span class="string">&quot;日&quot;</span>);</span><br><span class="line"><span class="comment">// Calendar没有专门的格式化方式，需要自己组合显示（好消息是比较灵活）</span></span><br></pre></td></tr></table></figure>

<h4 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h4><h5 id="前两代日期类的不足分析"><a href="#前两代日期类的不足分析" class="headerlink" title="前两代日期类的不足分析"></a>前两代日期类的不足分析</h5><p>Date类在java.util包中，在JDK1.0中被引入，但是它的大多数方法已经在JDK1.1中随着Calendar的隐忍而被弃用了.而Calendar类也存在问题：</p>
<ol>
<li>可变性：像日期和时间这样的类应该是不可变的。</li>
<li>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</li>
<li>格式化：只有Date可以格式化，Calendar不行。</li>
<li>此外，它们也不是线程安全的，不能处理闰秒（每隔两天多出一秒）等</li>
</ol>
<h5 id="JDK8引入的第三代日期类"><a href="#JDK8引入的第三代日期类" class="headerlink" title="JDK8引入的第三代日期类"></a>JDK8引入的第三代日期类</h5><p>以下类都在java.time包下<br>LocalDate（日期&#x2F;年月日），LocalTime（时间&#x2F;时分秒），LoacalDateTime（日期时间&#x2F;年月日时分秒）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">ld</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">lt</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line"></span><br><span class="line">System.out.println(ldt);</span><br><span class="line">System.out.println(ld);</span><br><span class="line">System.out.println(lt);</span><br><span class="line">System.out.println(ldt.getDayOfMonth());</span><br></pre></td></tr></table></figure>

<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><ol>
<li>now() &#x2F;&#x2F; 返回当前时间的全部信息</li>
<li>getYear&#x2F;MonthValue&#x2F;Month&#x2F;DayOfMonth&#x2F;Hour&#x2F;Minute&#x2F;Second() &#x2F;&#x2F; 返回年&#x2F;月（数字版，是整数值）&#x2F;月（英文版，是枚举类型）&#x2F;日&#x2F;小时&#x2F;分钟&#x2F;秒</li>
<li>isLeapYear() &#x2F;&#x2F; 判断是否是闰年（LocalDate）</li>
<li>plusxx() &#x2F;&#x2F; 增加某时间后</li>
<li>minusxx() &#x2F;&#x2F; 减少某时间后</li>
</ol>
<h5 id="格式日期类–DateTimeFormatter（Localxx-String）"><a href="#格式日期类–DateTimeFormatter（Localxx-String）" class="headerlink" title="格式日期类–DateTimeFormatter（Localxx -&gt; String）"></a>格式日期类–DateTimeFormatter（Localxx -&gt; String）</h5><p>类似于SimpleDateFormat。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH小时mm分钟ss秒&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> dtf.format(ldt);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>

<p>其中的字母格式也是需要自己在API里看。</p>
<h5 id="时间戳–Instant"><a href="#时间戳–Instant" class="headerlink" title="时间戳–Instant"></a>时间戳–Instant</h5><p>下属time包，Instant 是 java.util.Date 的现代替代品，提供了更好的 API 和更高的精度。可以用来表示一个时间戳，通常用于记录事件发生的精确时间。</p>
<p>通过静态方法now()获取表示当前时间戳的对象。通过from()方法可将Instant转成Date；通过Date的toInstant()可以吧Date转为Instant对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">test</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(test);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(test);;</span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> date.toInstant();</span><br><span class="line">System.out.println(instant);</span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>在前面实际上已经简单地提过集合了，可以自行翻看Java学习记录。</p>
<p>集合就是数学中的集合的概念：所有的元素都具有唯一的值，元素在其中没有顺序。</p>
<p>在Java中，集合可以动态保存任意多个对象，并提供了一系列方便的操作对象的方法。</p>
<h3 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">单列集合:</span><br><span class="line">java.util.Collection</span><br><span class="line">    |-- java.util.List</span><br><span class="line">    |    |-- java.util.ArrayList</span><br><span class="line">    |    |-- java.util.LinkedList</span><br><span class="line">    |    |-- java.util.Vector</span><br><span class="line">    |         |-- java.util.Stack</span><br><span class="line">    |</span><br><span class="line">    |-- java.util.Set</span><br><span class="line">    |    |-- java.util.HashSet</span><br><span class="line">    |    |    |-- java.util.LinkedHashSet</span><br><span class="line">    |    |</span><br><span class="line">    |    |-- java.util.TreeSet</span><br><span class="line">    |</span><br><span class="line">    |-- java.util.Queue</span><br><span class="line">         |-- java.util.PriorityQueue</span><br><span class="line">         |-- java.util.Deque</span><br><span class="line">              |-- java.util.ArrayDeque</span><br><span class="line">              |-- java.util.LinkedList (also implements Deque)</span><br><span class="line"></span><br><span class="line">双列集合：</span><br><span class="line">java.util.Map</span><br><span class="line">   |-- java.util.HashMap</span><br><span class="line">   |    |-- java.util.LinkedHashMap</span><br><span class="line">   |</span><br><span class="line">   |-- java.util.TreeMap</span><br><span class="line">   |</span><br><span class="line">   |-- java.util.Hashtable</span><br><span class="line">      |-- java.util.Properties</span><br></pre></td></tr></table></figure>

<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p><code>public interface Collection&lt;E&gt; extends Interface&lt;E&gt;</code></p>
<p>Collection接口实现类的特点：</p>
<ol>
<li>Collection实现子类可以存放多个元素，每个元素可以是Object</li>
<li>有些Collection的实现类可以存放重复元素，有些不可以</li>
<li>有些Collection的实现类，有些有序有些无序。</li>
<li>Collection接口没有直接的实现子类，是通过它的接口Set和List来实现的。</li>
</ol>
<p>常用方法：</p>
<ul>
<li>add() &#x2F;&#x2F; 添加单个元素</li>
<li>remove() &#x2F;&#x2F; 删除指定元素</li>
<li>contains() &#x2F;&#x2F; 查找元素是否存在</li>
<li>size() &#x2F;&#x2F; 获取元素个数</li>
<li>isEmpty() &#x2F;&#x2F; 判断是否为空</li>
<li>clear() &#x2F;&#x2F; 清空</li>
<li>adddAll() &#x2F;&#x2F; 添加多个元素</li>
<li>containsAll() &#x2F;&#x2F; 查找多个元素是否存在</li>
<li>removeAll() &#x2F;&#x2F; 删除多个元素</li>
</ul>
<h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p>Iterator对象称为迭代器，主要用于遍历Collection集合中的元素。</p>
<p>它的整个使用方式与指针类似。</p>
<p>所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器。</p>
<p>Iterator仅用于遍历集合，本身并不存放对象。</p>
<p>方法：</p>
<ul>
<li>boolean hasNext(): 如果仍有元素可以迭代，则返回 true。</li>
<li>E(集合中这个位置存放元素的类型) next(): 返回迭代的下一个元素。</li>
<li>void remove(): 从集合中移除迭代器返回的最后一个元素（可选操作）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">bookList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">bookList.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;三国演义&quot;</span>, <span class="number">10.1</span>));</span><br><span class="line">bookList.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;红楼梦&quot;</span>, <span class="number">34.6</span>));</span><br><span class="line">bookList.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;小李飞刀&quot;</span>, <span class="number">5.1</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> bookList.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123; <span class="comment">// 遍历</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">   System.out.println(<span class="string">&quot;obj= &quot;</span> + obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当退出while循环后，这时Iterator迭代器指向了最后的元素，如果希望再次像这样遍历，需要重置迭代器</span></span><br><span class="line"><span class="comment">// iterator = bookList.iterator();</span></span><br></pre></td></tr></table></figure>

<h5 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">bookList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">bookList.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;三国演义&quot;</span>, <span class="number">10.1</span>));</span><br><span class="line">bookList.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;红楼梦&quot;</span>, <span class="number">34.6</span>));</span><br><span class="line">bookList.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;小李飞刀&quot;</span>, <span class="number">5.1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Object object : bookList) &#123;</span><br><span class="line">   <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是for-each，但是遍历元素变成了集合里的对象类型。</p>
<p>也可以理解成简化版迭代器。</p>
<h4 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h4><p><code>List</code>接口继承自<code>Collection</code>，表示一个有序的集合，允许重复元素，每个元素都有对应整数型索引。常用实现类包括<code>ArrayList</code>、<code>LinkedList</code>和<code>Vector</code>。常用方法包括：</p>
<ul>
<li>get(int index): 获取指定位置的元素</li>
<li>set(int index, E element): <strong>替换</strong>指定位置的元素</li>
<li>add(int index, E element): 在指定位置<strong>插入</strong>元素</li>
<li>remove(int index): 删除指定位置的元素</li>
<li>indexOf(Object o): 返回元素第一次出现的位置</li>
<li>lastIndexOf(Object o): 返回元素最后一次出现的位置</li>
<li>subList(int start, int end) &#x2F;&#x2F; 返回从start到end的子集合</li>
</ul>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p>ArrayList是一个<strong>可调整大小的数组实现</strong>，适用于频繁的随机访问和迭代操作。</p>
<p>底层是用数组实现的。基本等同于Vector。</p>
<p>线程不安全但是效率高，在多线程情况下不建议使用。</p>
<p>常用方法：</p>
<ul>
<li>add(E e): 在列表末尾添加元素</li>
<li>add(int index, E element): 在指定位置插入元素</li>
<li>get(int index): 获取指定位置的元素</li>
<li>set(int index, E element): 替换指定位置的元素</li>
<li>remove(int index): 移除指定位置的元素</li>
<li>size(): 返回列表中的元素数量</li>
<li>clear(): 清空列表中的所有元素</li>
<li>contains(Object o): 判断列表是否包含指定元素</li>
</ul>
<p>ArrayList的底层扩容机制是通过动态数组实现的。当ArrayList中的元素数量超过其当前容量时，它会自动扩容。具体的 <em><strong>扩容机制</strong></em> 如下：</p>
<ol>
<li><p>初始容量：ArrayList在创建时可以指定初始容量，如果没有指定，则使用默认容量（通常是10）。</p>
</li>
<li><p>扩容条件：当添加新元素时，如果当前数组已满（即元素数量等于数组容量），则需要扩容。</p>
</li>
<li><p>扩容大小：扩容时，ArrayList会创建一个新的数组，其容量通常是旧数组容量的1.5倍（在某些实现中可能是2倍）。然后将旧数组中的元素复制到新数组中。</p>
</li>
<li><p>复制元素：将旧数组中的元素复制到新数组中，并将新数组的引用赋值给ArrayList的内部数组引用。</p>
</li>
</ol>
<p>这种扩容机制确保了ArrayList能够动态调整其大小，以适应不断增加的元素，同时尽量减少扩容操作的频率。</p>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>LinkedList是一个双向链表实现，适用于频繁的插入和删除操作。</p>
<p>常用方法：<br>add(E e): 在列表末尾添加元素<br>add(int index, E element): 在指定位置插入元素<br>addFirst(E e): 在列表开头插入元素<br>addLast(E e): 在列表末尾插入元素<br>get(int index): 获取指定位置的元素<br>getFirst(): 获取列表中的第一个元素<br>getLast(): 获取列表中的最后一个元素<br>remove(int index): 移除指定位置的元素<br>removeFirst(): 移除列表中的第一个元素<br>removeLast(): 移除列表中的最后一个元素<br>size(): 返回列表中的元素数量<br>clear(): 清空列表中的所有元素<br>contains(Object o): 判断列表是否包含指定元素</p>
<p>LinkedList的 <em><strong>底层机制</strong></em> 是基于双向链表实现的。双向链表是一种数据结构，其中每个节点包含三个部分：一个指向前一个节点的引用，一个存储数据的元素，以及一个指向下一个节点的引用。LinkedList的底层机制如下：</p>
<ol>
<li><p>节点结构：每个节点包含三个部分：</p>
<ul>
<li>prev：指向前一个节点的引用。</li>
<li>element：存储的数据元素。</li>
<li>next：指向下一个节点的引用。</li>
</ul>
</li>
<li><p>头节点和尾节点：LinkedList维护对头节点（first）和尾节点（last）的引用，以便快速访问列表的开头和结尾。</p>
</li>
<li><p>插入操作：</p>
<ul>
<li>在列表开头插入元素时，创建一个新节点，并将其next引用指向当前的头节点，同时更新头节点的prev引用指向新节点。</li>
<li>在列表末尾插入元素时，创建一个新节点，并将其prev引用指向当前的尾节点，同时更新尾节点的next引用指向新节点。</li>
<li>在指定位置插入元素时，遍历链表找到指定位置的节点，调整相邻节点的prev和next引用以插入新节点。</li>
</ul>
</li>
<li><p>删除操作：</p>
<ul>
<li>删除头节点时，将头节点的next引用更新为新的头节点，并将新头节点的prev引用设为null。</li>
<li>删除尾节点时，将尾节点的prev引用更新为新的尾节点，并将新尾节点的next引用设为null。</li>
<li>删除指定位置的节点时，遍历链表找到指定位置的节点，调整相邻节点的prev和next引用以移除该节点。</li>
</ul>
</li>
<li><p>访问操作：</p>
<ul>
<li>通过遍历链表找到指定位置的节点，然后返回该节点的元素。</li>
</ul>
</li>
</ol>
<p><em><strong>ArrayList与LinkList的比较</strong></em>：</p>
<ol>
<li>如果改查的操作多选ArrayList</li>
<li>增删操作多选LinkedList</li>
<li>一般来讲在程序中大部分都是查询，所以大部分情况下选ArrayList</li>
<li>实际情况请根据需求灵活选择</li>
</ol>
<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><p>Vector是一个同步的动态数组实现，适用于需要线程安全的场景。</p>
<p>常用方法：<br>add(E e): 在列表末尾添加元素<br>add(int index, E element): 在指定位置插入元素<br>get(int index): 获取指定位置的元素<br>set(int index, E element): 替换指定位置的元素<br>remove(int index): 移除指定位置的元素<br>size(): 返回列表中的元素数量<br>clear(): 清空列表中的所有元素<br>contains(Object o): 判断列表是否包含指定元素<br>capacity(): 返回向量的当前容量<br>ensureCapacity(int minCapacity): 确保向量至少具有指定的最小容量</p>
<p>Vector的底层扩容机制与ArrayList类似，但有一些不同之处。Vector是一个同步的动态数组实现，适用于需要线程安全的场景。其扩容机制如下：</p>
<ol>
<li><p>初始容量：Vector在创建时可以指定初始容量，如果没有指定，则使用默认容量（通常是10）。</p>
</li>
<li><p>扩容条件：当添加新元素时，如果当前数组已满（即元素数量等于数组容量），则需要扩容。</p>
</li>
<li><p>扩容大小：扩容时，Vector会创建一个新的数组，其容量通常是旧数组容量的2倍。这个倍数可以通过构造函数指定的capacityIncrement参数来改变。如果capacityIncrement为0，则每次扩容时容量加倍；否则，每次扩容时容量增加capacityIncrement的值。</p>
</li>
<li><p>复制元素：将旧数组中的元素复制到新数组中，并将新数组的引用赋值给Vector的内部数组引用。</p>
</li>
</ol>
<h4 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h4><p>Set 接口继承自 Collection，表示一个不包含重复元素的集合。常用实现类包括 HashSet、LinkedHashSet 和 TreeSet。常用方法与 Collection 接口类似，但不允许重复元素。</p>
<p>Set在遍历上可以和Collection一样使用迭代器和增强for循环，但是不能使用索引直接访问.</p>
<p>Set接口对象存放顺序是无序的（即添加顺序和取出顺序不一致），但是仍然是固定的。</p>
<p>常用方法：</p>
<ul>
<li>add(E e) &#x2F;&#x2F; 将指定的元素添加到集合中（如果该元素尚不存在）。</li>
<li>remove(Object o)：从集合中移除指定的元素（如果存在）。</li>
<li>contains(Object o)：判断集合中是否包含指定的元素。</li>
<li>size()：返回集合中的元素数量。</li>
<li>isEmpty()：判断集合是否为空。</li>
<li>clear()：清空集合中的所有元素。</li>
<li>iterator()：返回集合中元素的迭代器。</li>
<li>addAll(Collection&lt;? extends E&gt; c)：将指定集合中的所有元素添加到当前集合中（如果这些元素尚不存在）。</li>
<li>removeAll(Collection&lt;?&gt; c)：从当前集合中移除指定集合中包含的所有元素。</li>
<li>retainAll(Collection&lt;?&gt; c)：仅保留当前集合中那些包含在指定集合中的元素。</li>
<li>toArray()：将集合中的元素转换为数组。</li>
</ul>
<h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>HashSet 是基于哈希表实现的 Set 接口的实现类。它不保证集合的迭代顺序，特别是它不保证该顺序恒久不变（不保证存放顺序和取出顺序一致）。</p>
<p>可以存放null值，但是只能有一个。</p>
<p>HashSet不允许重复元素。其内部使用一个 HashMap 来存储元素，HashMap 的键（key）是元素本身，而值（value）是一个固定的对象。</p>
<p>当你向 HashSet 添加一个元素时，它会调用元素的 hashCode() 方法来计算哈希值，并将该哈希值用于确定元素在哈希表中的位置。如果两个元素的哈希值相同（即它们的 hashCode() 方法返回相同的值），则会进一步调用它们的 equals() 方法来检查它们是否相等。如果两个元素相等，则新的元素不会被添加到 HashSet 中，从而保证了 HashSet 中没有重复的元素。</p>
<p>常用方法：</p>
<ul>
<li>add(E e)：将指定的元素添加到集合中（如果该元素尚不存在）。</li>
<li>remove(Object o)：从集合中移除指定的元素（如果存在）。</li>
<li>contains(Object o)：判断集合中是否包含指定的元素。</li>
<li>size()：返回集合中的元素数量。</li>
<li>isEmpty()：判断集合是否为空。</li>
<li>clear()：清空集合中的所有元素。</li>
<li>iterator()：返回在此集合的元素上进行迭代的迭代器。</li>
</ul>
<p>在存放时，假如是常量，底层就会发现，但是如果是对象的话，因为hashcode不同，所以不会被认为是同一个元素。</p>
<p><em><strong>重点</strong></em>：</p>
<p>那么，假设我不想再加入对象时因为hashcode而让相同的元素加入集合，该怎么办呢？</p>
<p>答案是在这个对象的类里重写equals()和hashcode()。</p>
<p>equals() 方法控制在什么情况下两个对象被认为是相同的。它定义了对象相等的逻辑。<br>hashCode() 方法利用 Objects.hash() 保证相等对象的哈希码相同。它生成一个整数值，用于在哈希表等数据结构中快速查找和存储对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee) obj;</span><br><span class="line">   <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (other.name != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (age != other.age)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><p>LinkedHashSet 是 HashSet 的子类，具有可预知的迭代顺序。它底层是维护一个双向链表来记录元素的插入顺序。</p>
<p>LinkedHashSet根据元素的hashcode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的。</p>
<p>LinkedHashSet不允许添加重复元素。</p>
<p>常用方法：</p>
<ul>
<li>add(E e)：将指定的元素添加到集合中（如果该元素尚不存在）。</li>
<li>remove(Object o)：从集合中移除指定的元素（如果存在）。</li>
<li>contains(Object o)：判断集合中是否包含指定的元素。</li>
<li>size()：返回集合中的元素数量。</li>
<li>isEmpty()：判断集合是否为空。</li>
<li>clear()：清空集合中的所有元素。</li>
<li>iterator()：返回在此集合的元素上进行迭代的迭代器。</li>
</ul>
<h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>TreeSet 是基于红黑树实现的 Set 接口的实现类。它保证集合中的元素是有序的。</p>
<p>常用方法：</p>
<ul>
<li>add(E e)：将指定的元素添加到集合中（如果该元素尚不存在）。</li>
<li>remove(Object o)：从集合中移除指定的元素（如果存在）。</li>
<li>contains(Object o)：判断集合中是否包含指定的元素。</li>
<li>size()：返回集合中的元素数量。</li>
<li>isEmpty()：判断集合是否为空。</li>
<li>clear()：清空集合中的所有元素。</li>
<li>iterator()：返回在此集合的元素上进行迭代的迭代器。</li>
<li>first()：返回当前集合中的第一个（最小的）元素。</li>
<li>last()：返回当前集合中的最后一个（最大的）元素。</li>
<li>subSet(E fromElement, E toElement)：返回此集合部分元素的视图，范围从 fromElement（包括）到 toElement（不包括）。</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 接口表示一个键值对映射。</p>
<p>Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中。</p>
<p>Map中的key不允许重复（假如重复了就相当于替换），原因和HashSet一样。但是value可以重复。</p>
<p>Map的key和value可以为null。</p>
<h4 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h4><ol>
<li><p>先取出所有key，再通过key取出对应的value<br><code>Set = keyset = hm.keySet();</code></p>
<ol>
<li><p>增强for循环<strong>最常用的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">hm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">hm.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;浮士德&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;李箱&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;堂吉诃德&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;良秀&quot;</span>);</span><br><span class="line">hm.put(<span class="literal">null</span>, <span class="string">&quot;维吉利乌斯&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> hm.keySet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Object key : keySet) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;key:&quot;</span> + key + <span class="string">&quot; value:&quot;</span> + hm.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">hm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">hm.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;浮士德&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;李箱&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;堂吉诃德&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;良秀&quot;</span>);</span><br><span class="line">hm.put(<span class="literal">null</span>, <span class="string">&quot;维吉利乌斯&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> hm.keySet();</span><br><span class="line"></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keySet.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">   System.out.println(<span class="string">&quot;key:&quot;</span> + key + <span class="string">&quot; value:&quot;</span> + hm.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>只将所有的value取出<br><code>Collection values = hm.values();</code></p>
<ol>
<li><p>增强for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">hm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">hm.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;浮士德&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;李箱&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;堂吉诃德&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;良秀&quot;</span>);</span><br><span class="line">hm.put(<span class="literal">null</span>, <span class="string">&quot;维吉利乌斯&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> hm.values();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Object element : values) &#123;</span><br><span class="line">   System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">hm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">hm.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;浮士德&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;李箱&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;堂吉诃德&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;良秀&quot;</span>);</span><br><span class="line">hm.put(<span class="literal">null</span>, <span class="string">&quot;维吉利乌斯&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> hm.values();</span><br><span class="line"></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> values.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">   System.out.println(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>通过entrySet()得到键值对</p>
<ol>
<li><p>增强for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">hm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">hm.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;浮士德&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;李箱&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;堂吉诃德&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;良秀&quot;</span>);</span><br><span class="line">hm.put(<span class="literal">null</span>, <span class="string">&quot;维吉利乌斯&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> hm.entrySet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Object element : entrySet) &#123;</span><br><span class="line">   <span class="comment">// 将键值对转为Map.Entry（向下转型）</span></span><br><span class="line">   Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry)element;</span><br><span class="line">   System.out.println(<span class="string">&quot;key:&quot;</span> + m.getKey() + <span class="string">&quot; value:&quot;</span> + m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">hm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">hm.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;浮士德&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;李箱&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;堂吉诃德&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;良秀&quot;</span>);</span><br><span class="line">hm.put(<span class="literal">null</span>, <span class="string">&quot;维吉利乌斯&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> hm.entrySet();</span><br><span class="line"></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">      <span class="comment">// next()实际返回的是HashMap$Node类型</span></span><br><span class="line">      Map.<span class="type">Entry</span> <span class="variable">meEntry</span> <span class="operator">=</span> (Map.Entry)next;</span><br><span class="line">      <span class="comment">// 将键值对转为Map.Entry（向下转型）</span></span><br><span class="line">      System.out.println(<span class="string">&quot;key:&quot;</span> + meEntry.getKey() + <span class="string">&quot; value:&quot;</span> + meEntry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="HashMap（常用）"><a href="#HashMap（常用）" class="headerlink" title="HashMap（常用）"></a>HashMap（常用）</h4><p>基于哈希表实现，允许 null 键和 null 值。<br>无序，不保证顺序。<br>适合快速查找、插入和删除操作。</p>
<p>当你使用 HashMap 存储键值对时，每个键值对实际上是存储在一个内部类 <code>HashMap$Node</code> 中。<code>HashMap$Node</code> 是 <code>HashMap</code> 的一个静态内部类，它实现了 <code>Map.Entry</code> 接口。每个 <code>HashMap$Node</code> 对象包含一个键、一个值、一个哈希值以及指向下一个节点的引用（用于处理哈希冲突时的链表结构）。</p>
<p>当你向 <code>HashMap</code> 中添加一个键值对时， <code>HashMap</code> 会创建一个 <code>Node</code> 对象来存储这个键值对，并将其放入适当的桶中。如果发生哈希冲突（即多个键的哈希值相同），这些 <code>Node</code> 对象会以链表的形式链接在一起。</p>
<p>常用方法：</p>
<ul>
<li>put(K key, V value): 添加键值对</li>
<li>get(Object key): 获取指定键对应的值</li>
<li>remove(Object key): 删除指定键对应的键值对</li>
<li>size()：获取元素个数</li>
<li>isEmpty()：判断元素个数是否为零</li>
<li>clear()：清空</li>
<li><strong>containsKey(Object key)</strong>: 判断是否包含指定键</li>
<li><strong>containsValue(Object value)</strong>: 判断是否包含指定值</li>
<li><strong>keySet()</strong>: 返回所有键的<em>集合</em></li>
<li><strong>values()</strong>: 返回所有值的<em>集合</em></li>
<li><strong>entrySet()</strong>: 返回所有键值对的<em>集合</em></li>
</ul>
<h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><p>HashTable 是一种基于哈希表的数据结构，它实现了 Map 接口。HashTable 在 Java 中是一个线程安全的集合类，适用于多线程环境。</p>
<p>关键特性:</p>
<ol>
<li>线程安全：HashTable 的所有方法都是同步的，因此它是线程安全的，适用于多线程环境。</li>
<li><em><strong>不允许 null 键和 null 值</strong></em>：HashTable 不允许存储 null 键或 null 值。如果尝试插入 null 键或 null 值，会抛出 NullPointerException。</li>
<li>无序：HashTable 不保证元素的顺序。键值对的顺序可能会随着插入和删除操作而变化。</li>
<li>基于哈希表实现：HashTable 使用哈希表来存储键值对，具有较快的查找、插入和删除操作。</li>
</ol>
<p>常用方法:</p>
<ul>
<li>put(K key, V value)：将指定的键和值插入到哈希表中。如果哈希表中已经存在该键，则更新其对应的值。</li>
<li>get(Object key)：返回指定键所对应的值。如果哈希表中不包含该键，则返回 null。</li>
<li>remove(Object key)：从哈希表中移除指定键及其对应的值。</li>
<li>containsKey(Object key)：判断哈希表中是否包含指定的键。</li>
<li>containsValue(Object value)：判断哈希表中是否包含指定的值。</li>
<li>size()：返回哈希表中键值对的数量。</li>
<li>isEmpty()：判断哈希表是否为空。</li>
</ul>
<p>底层机制：</p>
<ol>
<li>底层有数组HashTable$Entry[] 初始化大小为11；</li>
<li>扩容机制：<ol>
<li>触发扩容<br>当哈希表中的键值对数量达到或超过临界值（哈希表在进行扩容之前所能容纳的最大键值对数量）时，哈希表会进行扩容。 threshold &#x3D; 8 &#x3D; 11 * 0.75</li>
<li>创建新的哈希表<br>扩容时，哈希表会创建一个新的、更大的哈希表。新的哈希表的容量通常是当前容量的两倍。例如，如果当前容量为 11，那么扩容后的新容量为 22。</li>
<li>重新计算哈希码<br>所有现有的键值对需要重新计算哈希码，并根据新的容量重新分配到新的哈希表中。这是因为哈希表的容量变化会影响哈希码的映射位置。</li>
<li>重新分配键值对<br>将旧哈希表中的所有键值对复制到新的哈希表中。由于容量增加，哈希冲突的概率会降低，从而提高哈希表的性能。</li>
</ol>
</li>
</ol>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><p>基本介绍：</p>
<ol>
<li>Properties类<strong>继承自HashTable类</strong>并且实现了Map接口，也使用键值对形式来保存数据。<strong>具有哈希表的所有特性</strong>。</li>
<li>键和值都是字符串：Properties 类中的键和值都是字符串类型。</li>
<li>Properties还可以用于从xxx.Properties文件中加载数据到Properties类对象，并进行读取和修改（说明：工作后 xxx.Properties文件通常作为配置文件，用于存储配置信息）</li>
</ol>
<p>常用方法：</p>
<ul>
<li>getProperty(String key)：用指定的键在此属性列表中搜索属性。</li>
<li>setProperty(String key, String value)：调用 put 方法，并使用字符串类型的键和值。</li>
<li>remove(String key)：删除该键对应的键值对。</li>
<li>list(PrintStream out)：将此属性列表（键和元素对）以适合人阅读的形式打印到指定的输出流。</li>
<li>load(InputStream inStream)：从输入流中读取属性列表（键和元素对）。</li>
<li>store(OutputStream out, String comments)：将此属性列表（键和元素对）写入输出流。</li>
</ul>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>TreeMap 是 Java 集合框架中的一个实现了 NavigableMap 接口的类，它基于红黑树（Red-Black Tree）实现。TreeMap 提供了有序的键值对存储，并且保证所有的键值对按照键的自然顺序（或通过提供的比较器顺序）排序。</p>
<p>关键特性<br>有序性：TreeMap 中的键值对是按键的自然顺序（或通过提供的比较器顺序）排序的。<br>基于红黑树实现：TreeMap 使用红黑树数据结构来存储键值对，保证了基本操作（如插入、删除、查找）的时间复杂度为 O(log n)。<br>不允许 null 键：TreeMap 不允许存储 null 键，但允许存储 null 值。<br>线程不安全：TreeMap 不是线程安全的。如果需要在多线程环境中使用，可以使用 Collections.synchronizedSortedMap 方法来获取线程安全的 TreeMap。</p>
<p>常用方法:</p>
<ul>
<li>put(K key, V value)：将指定的键和值插入到映射中。如果映射中已经存在该键，则更新其对应的值。</li>
<li>get(Object key)：返回指定键所对应的值。如果映射中不包含该键，则返回 null。</li>
<li>remove(Object key)：从映射中移除指定键及其对应的值。</li>
<li>firstKey()：返回映射中当前第一个（最小的）键。</li>
<li>lastKey()：返回映射中当前最后一个（最大的）键。</li>
<li>subMap(K fromKey, K toKey)：返回部分映射，其键的范围从 fromKey（包括）到 toKey（不包括）。</li>
<li>headMap(K toKey)：返回部分映射，其键的范围小于 toKey。</li>
<li>tailMap(K fromKey)：返回部分映射，其键的范围大于等于 fromKey。</li>
</ul>
<h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>Collections 是 Java 提供的一个实用工具类，包含了许多<strong>静态方法</strong>，用于操作或返回集合。Collections 类提供了对集合进行排序、搜索、同步化等操作的便捷方法。</p>
<p>常用方法：</p>
<ol>
<li><p>排序</p>
<ul>
<li><code>sort(List&lt;T&gt; list)</code>：对列表进行自然排序。</li>
<li><code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>：对列表进行自定义排序。</li>
</ul>
</li>
<li><p>搜索</p>
<ul>
<li><code>binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</code>：使用二分搜索法搜索列表中的指定对象。</li>
<li><code>binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c)</code>：使用二分搜索法搜索列表中的指定对象，使用自定义比较器。</li>
</ul>
</li>
<li><p>同步化</p>
<ul>
<li><code>synchronizedList(List&lt;T&gt; list)</code>：返回指定列表的同步（线程安全）列表。</li>
<li><code>synchronizedMap(Map&lt;K, V&gt; m)</code>：返回指定映射的同步（线程安全）映射。</li>
<li><code>synchronizedSet(Set&lt;T&gt; s)</code>：返回指定集合的同步（线程安全）集合。</li>
</ul>
</li>
<li><p>不可变集合</p>
<ul>
<li><code>unmodifiableList(List&lt;? extends T&gt; list)</code>：返回指定列表的不可修改视图。</li>
<li><code>unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code>：返回指定映射的不可修改视图。</li>
<li><code>unmodifiableSet(Set&lt;? extends T&gt; s)</code>：返回指定集合的不可修改视图。</li>
</ul>
</li>
<li><p>其他实用方法</p>
<ul>
<li><code>reverse(List&lt;?&gt; list)</code>：反转指定列表中元素的顺序。</li>
<li><code>shuffle(List&lt;?&gt; list)</code>：使用默认随机源随机排列指定列表中的元素。</li>
<li><code>fill(List&lt;? super T&gt; list, T obj)</code>：用指定元素替换指定列表中的所有元素。</li>
<li><code>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</code>：将源列表中的所有元素复制到目标列表中。</li>
<li><code>min(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; c)</code>：根据元素的自然顺序，返回给定集合中的最小元素。</li>
<li><code>max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; c)</code>：根据元素的自然顺序，返回给定集合中的最大元素。</li>
<li><code>frequency(Collection&lt;? extends T&gt; coll, Object o)</code>：返回指定集合中指定元素的出现次数。</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/head.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/head.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">ZUTA39</div><div class="post-copyright__author_desc">知行合一</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://zuta39.github.io/2024/11/08/JavaTalkLater/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://zuta39.github.io/2024/11/08/JavaTalkLater/')">Java后日谈</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://zuta39.github.io/2024/11/08/JavaTalkLater/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Java后日谈&amp;url=https://zuta39.github.io/2024/11/08/JavaTalkLater/&amp;pic=/img/article_background2.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zuta39.github.io" target="_blank">ZUTA的观测站</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>编程语言<span class="tagsPageCount">2</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/article_background4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/08/DataBaseStudyRecord/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/article_background1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据库系统概论</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/24/ComputerComposition/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/article_background4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2024/11/08/JavaStudyRecord/" title="Java 学习记录（已完结）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/article_background1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-11-08</div><div class="title">Java 学习记录（已完结）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2021/01/18/2d326ec6556d4.jpg" alt="status"/></div></div><div class="author-info__description">你好！这是我的太空观测基地👾</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">ZUTA39</h1><div class="author-info__desc">知行合一</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/zuta39" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的观测站!来和我一起观测宇宙中有趣的事物吧！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E6%83%85%E6%8F%90%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text">前情提要</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Emain%E6%96%B9%E6%B3%95%E7%9A%84%E6%9B%B4%E5%A4%9A%E7%BB%86%E8%8A%82"><span class="toc-number">1.1.</span> <span class="toc-text">关于main方法的更多细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%88-%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">代码块（*）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8%E2%80%93%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">静态方法与属性的使用–单例设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.4.</span> <span class="toc-text">final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA"><span class="toc-number">1.4.2.</span> <span class="toc-text">注意事项与细节讨论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84super"><span class="toc-number">1.5.</span> <span class="toc-text">关于继承中的super</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">抽象与接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%EF%BC%88abstract%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">抽象（abstract）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.1.</span> <span class="toc-text">抽象基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="toc-number">2.1.2.</span> <span class="toc-text">抽象类的注意事项与细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">接口（interface）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.2.1.</span> <span class="toc-text">接口基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.2.2.</span> <span class="toc-text">接口注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.2.3.</span> <span class="toc-text">继承与接口的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-number">2.2.4.</span> <span class="toc-text">接口的多态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">内部类的基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">内部类的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">3.2.1.</span> <span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">3.2.2.</span> <span class="toc-text">匿名内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">匿名内部类的基本语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">3.2.3.</span> <span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">3.2.4.</span> <span class="toc-text">静态内部类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">枚举与注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">4.1.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">4.1.1.</span> <span class="toc-text">自定义枚举类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Enum%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">4.1.2.</span> <span class="toc-text">Enum枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">枚举类的基本语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">使用细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.2.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Override%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.2.1.</span> <span class="toc-text">Override注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Despressted%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.2.2.</span> <span class="toc-text">Despressted注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SuppressWarnings%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.2.3.</span> <span class="toc-text">SuppressWarnings注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%85%83%E6%B3%A8%E8%A7%A3%EF%BC%88-%EF%BC%89"><span class="toc-number">4.2.4.</span> <span class="toc-text">四种元注解（*）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">5.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE"><span class="toc-number">5.1.</span> <span class="toc-text">异常体系图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">5.2.</span> <span class="toc-text">常见的异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">5.2.1.</span> <span class="toc-text">运行时异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%BC%82%E5%B8%B8"><span class="toc-number">5.2.2.</span> <span class="toc-text">编译异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%A6%82%E5%BF%B5"><span class="toc-number">5.3.1.</span> <span class="toc-text">异常处理概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%88%86%E7%B1%BB"><span class="toc-number">5.3.2.</span> <span class="toc-text">异常处理分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">5.4.</span> <span class="toc-text">自定义异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw%E5%92%8Cthrows%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">5.5.</span> <span class="toc-text">throw和throws的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%88Wrapper%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">包装类（Wrapper）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.1.</span> <span class="toc-text">包装类的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.1.2.</span> <span class="toc-text">包装类的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B1%9E%E6%80%A7"><span class="toc-number">6.1.3.</span> <span class="toc-text">包装类的常用静态方法与属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.1.4.</span> <span class="toc-text">包装类注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">String类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.2.1.</span> <span class="toc-text">String类的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="toc-number">6.2.2.</span> <span class="toc-text">String类的常用构造器与对象创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%89%B9%E6%80%A7"><span class="toc-number">6.2.3.</span> <span class="toc-text">字符串特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.4.</span> <span class="toc-text">String类的常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer%E7%B1%BB%E5%92%8CStringBuilder%E7%B1%BB"><span class="toc-number">6.3.</span> <span class="toc-text">StringBuffer类和StringBuilder类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StringButter%E7%B1%BB"><span class="toc-number">6.3.1.</span> <span class="toc-text">StringButter类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#StringBuffer%E7%B1%BB%E7%AE%80%E4%BB%8B"><span class="toc-number">6.3.1.1.</span> <span class="toc-text">StringBuffer类简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StringBuffer%E7%B1%BB%E4%B8%8EString%E7%B1%BB%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">6.3.1.2.</span> <span class="toc-text">StringBuffer类与String类的比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StringBuffer%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">6.3.1.3.</span> <span class="toc-text">StringBuffer实例化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StringBuffer%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.1.4.</span> <span class="toc-text">StringBuffer类的常用方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuilder%E7%B1%BB"><span class="toc-number">6.3.2.</span> <span class="toc-text">StringBuilder类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#StringBuilder%E7%B1%BB%E7%AE%80%E4%BB%8B"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">StringBuilder类简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StringBuilder%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.2.2.</span> <span class="toc-text">StringBuilder常用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#String%E3%80%81StringBuilder%E3%80%81StringBuffer%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">6.3.2.3.</span> <span class="toc-text">String、StringBuilder、StringBuffer的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math%E7%B1%BB"><span class="toc-number">6.4.</span> <span class="toc-text">Math类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays%E7%B1%BB"><span class="toc-number">6.5.</span> <span class="toc-text">Arrays类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System%E7%B1%BB"><span class="toc-number">6.6.</span> <span class="toc-text">System类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#System%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.1.</span> <span class="toc-text">System类的常见方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigInteger%E7%B1%BB%E5%92%8CBigDecimal%E7%B1%BB"><span class="toc-number">6.7.</span> <span class="toc-text">BigInteger类和BigDecimal类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">6.8.</span> <span class="toc-text">日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB%E2%80%93Date%E7%B1%BB"><span class="toc-number">6.8.1.</span> <span class="toc-text">第一代日期类–Date类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Date%E7%9A%84%E7%89%B9%E5%AE%9A%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%A7%A3%E6%9E%90%E8%BE%93%E5%87%BA%EF%BC%88Date-String%EF%BC%89"><span class="toc-number">6.8.1.1.</span> <span class="toc-text">Date的特定格式化解析输出（Date -&gt; String）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#String-Date"><span class="toc-number">6.8.1.2.</span> <span class="toc-text">String -&gt; Date</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB%E2%80%93Calendar%E7%B1%BB"><span class="toc-number">6.8.2.</span> <span class="toc-text">第二代日期类–Calendar类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">6.8.3.</span> <span class="toc-text">第三代日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E4%B8%A4%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E4%B8%8D%E8%B6%B3%E5%88%86%E6%9E%90"><span class="toc-number">6.8.3.1.</span> <span class="toc-text">前两代日期类的不足分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK8%E5%BC%95%E5%85%A5%E7%9A%84%E7%AC%AC%E4%B8%89%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">6.8.3.2.</span> <span class="toc-text">JDK8引入的第三代日期类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.8.3.3.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E6%97%A5%E6%9C%9F%E7%B1%BB%E2%80%93DateTimeFormatter%EF%BC%88Localxx-String%EF%BC%89"><span class="toc-number">6.8.3.4.</span> <span class="toc-text">格式日期类–DateTimeFormatter（Localxx -&gt; String）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E2%80%93Instant"><span class="toc-number">6.8.3.5.</span> <span class="toc-text">时间戳–Instant</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">7.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB"><span class="toc-number">7.1.</span> <span class="toc-text">集合框架体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.2.</span> <span class="toc-text">Collection接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">7.2.1.</span> <span class="toc-text">遍历方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">7.2.1.2.</span> <span class="toc-text">增强for循环</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List-%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.2.2.</span> <span class="toc-text">List 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList"><span class="toc-number">7.2.2.1.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedList"><span class="toc-number">7.2.2.2.</span> <span class="toc-text">LinkedList</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vector"><span class="toc-number">7.2.2.3.</span> <span class="toc-text">Vector</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set-%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.2.3.</span> <span class="toc-text">Set 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HashSet"><span class="toc-number">7.2.3.1.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">7.2.3.2.</span> <span class="toc-text">LinkedHashSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TreeSet"><span class="toc-number">7.2.3.3.</span> <span class="toc-text">TreeSet</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">7.3.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.1.</span> <span class="toc-text">遍历方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">7.3.2.</span> <span class="toc-text">HashMap（常用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashTable"><span class="toc-number">7.3.3.</span> <span class="toc-text">HashTable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Properties"><span class="toc-number">7.3.4.</span> <span class="toc-text">Properties</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap"><span class="toc-number">7.3.5.</span> <span class="toc-text">TreeMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">7.4.</span> <span class="toc-text">Collections工具类</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/24/ComputerComposition/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/article_background4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/11/24/ComputerComposition/" title="无题">无题</a><time datetime="2024-11-24T14:36:41.292Z" title="发表于 2024-11-24 22:36:41">2024-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/08/JavaTalkLater/" title="Java后日谈"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/article_background2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java后日谈"/></a><div class="content"><a class="title" href="/2024/11/08/JavaTalkLater/" title="Java后日谈">Java后日谈</a><time datetime="2024-11-08T14:19:06.000Z" title="发表于 2024-11-08 22:19:06">2024-11-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/08/DataBaseStudyRecord/" title="数据库系统概论"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/article_background1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库系统概论"/></a><div class="content"><a class="title" href="/2024/11/08/DataBaseStudyRecord/" title="数据库系统概论">数据库系统概论</a><time datetime="2024-11-08T14:19:02.000Z" title="发表于 2024-11-08 22:19:02">2024-11-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/08/JavaStudyRecord/" title="Java 学习记录（已完结）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/article_background1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java 学习记录（已完结）"/></a><div class="content"><a class="title" href="/2024/11/08/JavaStudyRecord/" title="Java 学习记录（已完结）">Java 学习记录（已完结）</a><time datetime="2024-11-08T14:19:02.000Z" title="发表于 2024-11-08 22:19:02">2024-11-08</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:1307603452@qq.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/head.jpg" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/zuta39" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div><div id="workboard"><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 By <a class="footer-bar-link" href="/" title="ZUTA39" target="_blank">ZUTA39</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  getScript('https://sdk.jinrishici.com/v2/browser/jinrishici.js').then(() => {
    jinrishici.load(result =>{
      if (true) {
        const sub = []
        const content = result.data.content
        sub.unshift(content)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = result.data.content
      }
    })
  })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼的图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼的图床"/><span class="back-menu-item-text">安知鱼的图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">编程语言<sup>2</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3%E5%AD%A6%E7%A7%91/" style="font-size: 0.88rem;">计算机相关学科<sup>1</sup></a></div></div><hr/></div></div><div id="keyboard-tips"><div class="keyboardTitle">博客快捷键</div><div class="keybordList"><div class="keybordItem"><div class="keyGroup"><div class="key">shift K</div></div><div class="keyContent"><div class="content">关闭快捷键功能</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift A</div></div><div class="keyContent"><div class="content">打开/关闭中控台</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift M</div></div><div class="keyContent"><div class="content">播放/暂停音乐</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift D</div></div><div class="keyContent"><div class="content">深色/浅色显示模式</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift S</div></div><div class="keyContent"><div class="content">站内搜索</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift R</div></div><div class="keyContent"><div class="content">随机访问</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift H</div></div><div class="keyContent"><div class="content">返回首页</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift F</div></div><div class="keyContent"><div class="content">友链鱼塘</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift L</div></div><div class="keyContent"><div class="content">友链页面</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift P</div></div><div class="keyContent"><div class="content">关于本站</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift I</div></div><div class="keyContent"><div class="content">原版/本站右键菜单</div></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="810012339" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("11/14/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2024 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 ZUTA39 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("11/14/2024 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "";
        img.title = "";
        img.alt = "";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>